<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-04-23T16:15:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">MN Lee’s IT Blog</title><subtitle>이 사이트의 Article들은 개인의 경험을 기술한 것으로 특정 제품의 공식 가이드가 아닙니다. 기술된 제품들의 버전에 따라 문서의 방법이 바르게 동작하지 않을 수 있습니다.</subtitle><entry><title type="html">Oracle Kubernetes Engine에 WebLogic Domain 올리기 - Nginx 추가</title><link href="http://localhost:4000/cloud/2019/k8s-weblogic-nginx/" rel="alternate" type="text/html" title="Oracle Kubernetes Engine에 WebLogic Domain 올리기 - Nginx 추가" /><published>2019-04-23T00:00:00+09:00</published><updated>2019-04-23T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/k8s-weblogic-nginx</id><content type="html" xml:base="http://localhost:4000/cloud/2019/k8s-weblogic-nginx/">&lt;p&gt;이 예제에서는 이전에 생성한 WebLogic Domain 앞 단에 Frontend 역할을 수행하는 Nginx를 추가해 볼 것이다.&lt;/p&gt;

&lt;h1 id=&quot;architecture&quot;&gt;Architecture&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic3/00_arch3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;prerequistes&quot;&gt;Prerequistes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Oracle Kubernetes Engine(OKE)&lt;/li&gt;
  &lt;li&gt;Oracle File System&lt;/li&gt;
  &lt;li&gt;Nginx&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;nginx-deployment-구성하기&quot;&gt;Nginx Deployment 구성하기&lt;/h1&gt;

&lt;p&gt;이전의 WebLogic Domain 환경이 그대로 남아있는 상황에서 &lt;strong&gt;Nginx&lt;/strong&gt; 구성만 추가해 볼 것이다.
Nginx를 통해 WebLogic Cluster로 요청이 넘어갈 수 있도록 WebLogic Server와 연결하는 구성이 필요하다.
Nginx와 WebLogic Server 간의 연결 방법에 대해서는 Nginx 문서에 잘 설명되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.nginx.com/nginx/deployment-guides/oracle-weblogic-server-load-balancing-nginx-plus/&quot;&gt;Load Balancing Oracle WebLogic Server with NGINX Open Source and NGINX Plus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;weblogic-basicconf&quot;&gt;weblogic-basic.conf&lt;/h2&gt;

&lt;p&gt;WebLogic Server 연결을 위해 &lt;strong&gt;weblogic-basic.conf&lt;/strong&gt; 파일이 필요하다. 파일 내용은 아래를 참고한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxy_cache_path /tmp/NGINX_wl_cache/ keys_zone=backcache:10m;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

upstream weblogic {
    #ip_hash;
    hash $remote_addr;

    # WebLogic Cluster Kubernetes Service Name:Port
    server domain1-cluster-cluster-1:8001;
}

server {
    listen 80;
    server_name  _;

    location / {
        proxy_cache backcache;
        proxy_pass http://weblogic;

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;nginxconf&quot;&gt;nginx.conf&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;nginx.conf&lt;/strong&gt; 내용은 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include conf.d/weblogic-basic.conf;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;
    keepalive_timeout  65;
    #gzip  on;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;configmap-yaml&quot;&gt;ConfigMap YAML&lt;/h2&gt;

&lt;p&gt;Nginx 배포를 위해서 Deployment 구성 파일을 작성할 것이다. Nginx 이미지는 Docker Hub에서 가져와서 사용할 것이다. 이 Base 이미지의 기본 구성 파일이 아닌 내가 작성한 Custom Configuration을 사용하도록 하기 위햐여 Kubernetes의 &lt;strong&gt;ConfigMap&lt;/strong&gt; 기능을 이용할 것이다.&lt;/p&gt;

&lt;p&gt;커스텀 &lt;strong&gt;nginx.conf&lt;/strong&gt;와 &lt;strong&gt;weblogic-basic.conf&lt;/strong&gt;를 ConfigMap으로 만들기 위한 구성 내용이다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ConfigMap&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-cm&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;nginx.conf&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;user  nginx;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;worker_processes  1;&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;error_log  /var/log/nginx/error.log warn;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;pid        /var/run/nginx.pid;&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;events {&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;worker_connections  1024;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;http {&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;include conf.d/weblogic-basic.conf;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;include       /etc/nginx/mime.types;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;default_type  application/octet-stream;&lt;/span&gt;

        &lt;span class=&quot;no&quot;&gt;log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '&lt;/span&gt;
                          &lt;span class=&quot;no&quot;&gt;'$status $body_bytes_sent &quot;$http_referer&quot; '&lt;/span&gt;
                          &lt;span class=&quot;no&quot;&gt;'&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';&lt;/span&gt;

        &lt;span class=&quot;no&quot;&gt;access_log  /var/log/nginx/access.log  main;&lt;/span&gt;

        &lt;span class=&quot;no&quot;&gt;sendfile        on;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;#tcp_nopush     on;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;keepalive_timeout  65;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;#gzip  on;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;weblogic-basic.conf&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;proxy_cache_path /tmp/NGINX_wl_cache/ keys_zone=backcache:10m;&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;map $http_upgrade $connection_upgrade {&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;default upgrade;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;''      close;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;upstream weblogic {&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;hash $remote_addr;&lt;/span&gt;

        &lt;span class=&quot;no&quot;&gt;# WebLogic Cluster Kubernetes Service Name:Port&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;server domain1-cluster-cluster-1:8001;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;server {&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;listen 80;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;server_name  _;&lt;/span&gt;

        &lt;span class=&quot;no&quot;&gt;location / {&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;proxy_cache backcache;&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;proxy_pass http://weblogic;&lt;/span&gt;

        &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;deployment-yaml&quot;&gt;Deployment YAML&lt;/h2&gt;

&lt;p&gt;Nginx를 배포하기 위한 구성 파일이다. Container에서 위에서 구성한 &lt;strong&gt;ConfigMap&lt;/strong&gt;을 Volume으로 Mount하여 Custom Configuration을 참조하게된다&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-dp&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;80&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;volumeMounts&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;mountPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/etc/nginx/nginx.conf&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# mount nginx.conf volume&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-conf&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;subPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx.conf&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;volumeMounts&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;mountPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/etc/nginx/conf.d&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# mount conf.d where weblogic-basic.conf is located&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-confd&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-conf&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;configMap&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-cm&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# refer to ConfigMap for `nginx-conf` &lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx.conf&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx.conf&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-confd&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;configMap&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-cm&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# refer to ConfigMap for `nginx-confd`&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;weblogic-basic.conf&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;weblogic-basic.conf&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;service-yaml&quot;&gt;Service YAML&lt;/h2&gt;

&lt;p&gt;Load Balancer를 통해 외부에서 접속하기 위한 서비스를 추가한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이전 환경에서 포트 80을 사용하고 있는 서비스 (domain1-cluster1-lb-ext)는 미리 삭제해 둔다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ngnix-lb-ext&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;service.beta.kubernetes.io/oci-load-balancer-shape&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;100Mbps&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;service.beta.kubernetes.io/oci-load-balancer-backend-protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;HTTP&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;80&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;배포하기&quot;&gt;배포하기&lt;/h2&gt;

&lt;p&gt;위에서 설명한 ConfigMap, Deployment, Service를 하나의 파일로 구성하여 한번에 적용할 것이다.
&lt;strong&gt;nginx-dp-cm.yaml&lt;/strong&gt; 파일을 생성하여 위 3개의 구성 내용을 넣어준다.
파일이 완료되었으면 kubectl를 통해 적용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; kubectl apply -f nginx-dp-cm.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;배포가 완료되면 다음과 같이 보일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic3/01_nginx.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nginx Service의 External IP를 통해 서비스에 접근해 보자.
WebLogic Cluster로 요청이 정상적으로 Forward 되어 서비스 되는 것을 볼 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic3/02_weblogic_app.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;persistent-session&quot;&gt;Persistent Session&lt;/h1&gt;

&lt;p&gt;위 구성으로 테스트해 보면 매 요청 마다 다른 Managed Server가 호출되는 것을 볼 수 있을 것이다. WebLogic Cluster 간에 세션이 공유되기 때문에, 어느 Managed Server로 접속되더라도 세션이 유지되긴 하지만 동일 세션일 경우 같은 Managed Server로 요청이 갈수 있도록 하는 &lt;strong&gt;Sticky Session&lt;/strong&gt; 구성은 &lt;strong&gt;Nginx Plus&lt;/strong&gt;에서 가능하므로
여기에서는 IP Hash를 통해 같은 Backend Server로 요청이 되어질 수 있도록 하는 구성으로 바꿔보려고 한다.&lt;/p&gt;

&lt;p&gt;이를 위해서는 Backend Server들이 upstream에 리스트 되어야 하기 때문에 cluster service를 사용하지 않고 Managed Server 각각을 list 해줘야 한다.
변경된 &lt;strong&gt;weblogic-basic.conf&lt;/strong&gt;는 다음과 같다.&lt;/p&gt;

&lt;h2 id=&quot;weblogic-basicconf-1&quot;&gt;weblogic-basic.conf&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxy_cache_path /tmp/NGINX_wl_cache/ keys_zone=backcache:10m;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

upstream weblogic {
    #ip_hash;
    hash $remote_addr;

    # WebLogic Managed Server Kubernetes Service Name:Port
    server domain1-managed-server1:8001;
    server domain1-managed-server2:8001;
    server domain1-managed-server3:8001;

}

server {
    listen 80;
    server_name  _;

    location / {
        proxy_cache backcache;
        proxy_pass http://weblogic;

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변경 사항을 다시 반영한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; kubectl apply -f nginx-dp-cm.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CofigMap만 변경되었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic3/03_update.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nginx Container Restart를 위해서 다음 작업을 수행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; kubectl scale deployment nginx-dp --replicas=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic3/04_scale0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다시 Container를 구동한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; kubectl scale deployment nginx-dp --replicas=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic3/05_scale1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 다시 애플리케이션을 브라우저에서 테스트 해보면 요청 시마다 다른 Managed Server로 접속되지 않고 한 Managed Server로 고정되는 것을 볼 수 있을 것이다.&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://oracle.github.io/weblogic-kubernetes-operator/&quot;&gt;Oracle WebLogic Server Kubernetes Operator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.nginx.com/nginx/deployment-guides/oracle-weblogic-server-load-balancing-nginx-plus/&quot;&gt;Load Balancing Oracle WebLogic Server with NGINX Open Source and NGINX Plus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="WebLogic" /><category term="Kubernetes" /><category term="Oracle Kubernetes Engine" /><category term="Persistent Volume" /><category term="Nginx" /><summary type="html">이 예제에서는 이전에 생성한 WebLogic Domain 앞 단에 Frontend 역할을 수행하는 Nginx를 추가해 볼 것이다.</summary></entry><entry><title type="html">Oracle Kubernetes Engine에 WebLogic Domain 올리기 - Persistent Volume 사용</title><link href="http://localhost:4000/cloud/2019/k8s-weblogic-pv/" rel="alternate" type="text/html" title="Oracle Kubernetes Engine에 WebLogic Domain 올리기 - Persistent Volume 사용" /><published>2019-04-19T00:00:00+09:00</published><updated>2019-04-19T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/k8s-weblogic-pv</id><content type="html" xml:base="http://localhost:4000/cloud/2019/k8s-weblogic-pv/">&lt;p&gt;이 전 예제에서는 Docker Image 내에 WebLogic Binary와 Domain 구성 정보가 모두 들어있는 Sample을 이용하였다. 
여기서는 WebLogic Binary는 Docker Image 내에 존재 하지만 Domain 정보는 Persistent Volume을 사용하여 외부에 구성하는 예제를 살펴볼 것 이다.&lt;/p&gt;

&lt;p&gt;이전 글에서 사용한 &lt;strong&gt;WebLogic Operator&lt;/strong&gt;의 Sample에 Persistent Volume을 사용하는 예제도 함께 들어있다. 
이 예제를 이용하여 Persistent Volume을 &lt;strong&gt;Oracle Cloud Infrastructure&lt;/strong&gt;의 &lt;strong&gt;File System&lt;/strong&gt;을 사용하도록 구성하는 방법으로 설명할 것이다.&lt;/p&gt;

&lt;h1 id=&quot;architecture&quot;&gt;Architecture&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/arch2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;prerequistes&quot;&gt;Prerequistes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Oracle Kubernetes Engine(OKE)&lt;/li&gt;
  &lt;li&gt;Oracle File System&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;이전-과정에서-했던-작업-돌아보기&quot;&gt;이전 과정에서 했던 작업 돌아보기&lt;/h1&gt;

&lt;p&gt;이전 과정에서 수행 했던 작업들은 환경에 그대로 존재한다면 다시 수행할 필요 없이 그대로 이용하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Oracle Kubernetes Engine(OKE) 접속 확인&lt;/li&gt;
  &lt;li&gt;WebLogic Operator 설치&lt;/li&gt;
  &lt;li&gt;WebLogic Image 준비 : 이 예제에서는 &lt;strong&gt;store/oracle/weblogic:12.2.1.3&lt;/strong&gt; 이미지를 Kubernetes WebLogic Operator Job 생성 시 직접 당겨오기 때문에 미리 준비해 둘 필요는 없다.&lt;/li&gt;
  &lt;li&gt;WebLogic Domain 준비 : 이 예제에서는 &lt;strong&gt;Kubernetes WebLogic Operator Job&lt;/strong&gt;이 돌면서 Persistent Volume에 Domain 구성 파일들을 생성한다.&lt;/li&gt;
  &lt;li&gt;WebLogic Kubernetes Operator 샘플 Git Clone&lt;/li&gt;
  &lt;li&gt;WebLogic Domain Credential : 같은 id/password를 사용한다면 이전에 만든것을 재사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;file-system-구성&quot;&gt;File System 구성&lt;/h1&gt;
&lt;p&gt;도메인 구성 스크립트를 수행하기 전에 File System이 먼저 구성되어 있어야 한다.
&lt;strong&gt;OKE&lt;/strong&gt;를 위해 구성된 &lt;strong&gt;VCN (Virtual Cloud Network)&lt;/strong&gt;에 File System을 위한 별도의 &lt;strong&gt;Subnet&lt;/strong&gt;을 구성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/01_subnet.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/01_subnet2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;File Storage&lt;/strong&gt; 메뉴로 이동해서 &lt;strong&gt;File System&lt;/strong&gt;을 생성을 클릭한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/02_filestorage.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hide Details&lt;/strong&gt; 부분에 &lt;strong&gt;Edit Details&lt;/strong&gt;가 있었을 것이다. 이 버튼을 클릭하여 File System 이름을 다음처럼 바꿔준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/03_filesystem1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mount Target&lt;/strong&gt; 정보에서도 &lt;strong&gt;Edit Details&lt;/strong&gt;를 클릭하여 Mount Target을 생상하도록 하고, Mount Target이 앞에서 생성한 &lt;strong&gt;Subnet&lt;/strong&gt;에 생성되도록 해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/03_filesystem2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;File System과 Mount Target이 생성되고 나면 다음과 같이 보여진다.
Mount Target의 &lt;strong&gt;IP&lt;/strong&gt;는 다음 과정에서 &lt;strong&gt;Persistent Volume&lt;/strong&gt;을 설정할 때 사용할 것이니 잘 기록해 둔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/04_mt.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Export Path&lt;/strong&gt;가 아래와 같이 설정되었다. 이 Path도 &lt;strong&gt;Persistent Volume&lt;/strong&gt; 설정 시에 필요한 정보이다. 이미 예제에서 사용하는 path (/shared)와 동일하게 생성하였기 때문에 다르게 생성하였을 경우에만 나중 사용을 위해 기록해 둔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/05_export.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OKE worker node에서 Mount Target에 접근하기 위해서는 &lt;strong&gt;Security List&lt;/strong&gt;에 몇 가지 Rule 구성해 줘야 한다. 구성 방법은 아래 매뉴얼을 참고하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.cloud.oracle.com/iaas/Content/File/Tasks/securitylistsfilestorage.htm?Highlight=mount%20target%20security%20list&quot;&gt;Configuring VCN Security List Rules for File Storage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기에서는 &lt;strong&gt;편의상&lt;/strong&gt; Mount Target이 속한 Subnet(nfs-sn)이 Worker Node subnet이 사용하는 &lt;strong&gt;Security List&lt;/strong&gt;와 같은 것을 사용하도록 설정하였기 때문에 이미 모든 Worker Node들에서 부터의 모든 Protocol을 받을 수 있게 되어있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/06_securitylist.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Security List를 다르게 해 줬다면 문서에서 설명하는 대로 Rule들을 지정해 줘야 한다.&lt;/p&gt;

&lt;h1 id=&quot;pv-사용-도메인-구성&quot;&gt;PV 사용 도메인 구성&lt;/h1&gt;

&lt;p&gt;WebLogic Operator의 Sample Script 디렉토리로 이동한다.&lt;/p&gt;

&lt;p&gt;Domain을 생성하기 앞서서 &lt;strong&gt;Persistent Volume&lt;/strong&gt;을 먼저 생성해야 하기 때문에 아래 단계를 수행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cd weblogic-kubernetes-operator/kubernetes/samples/scripts/create-weblogic-domain-pv-pvc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 디렉토리에서 &lt;strong&gt;create-pv-pvc-inputs.yaml&lt;/strong&gt; 파일을 열어 다음 부분을 수정한다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;weblogicDomainStorageType&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;NFS&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Mount Target의 IP&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;weblogicDomainStorageNFSServer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;10.0.13.3&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Mount Target의 Export Path, 위애서 설명한 데로 생성했다면 그대로 두면 된다.&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;weblogicDomainStoragePath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/shared&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;수정된 input 파일을 기반으로 다음 스크립트를 실행한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; ./create-pv-pvc.sh -i create-pv-pvc-inputs.yaml -o ./pv-pvc-output –e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/07_pv_pvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;output 디렉토리로 이동하여 생성된 yaml 파일을 확인하고 kubectl로 적용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; kubectl apply -f ./domain1-weblogic-sample-pv.yaml
&amp;gt; kubectl apply -f ./domain1-weblogic-sample-pvc.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/08_apply_pv_pvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘 생성되었는지 확인한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/09_get_pv_pvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 도메인을 생성할 단계이다.&lt;/p&gt;

&lt;p&gt;도메인 생성을 위해 해당 스크립트가 위치한 디렉토리로 이동한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cd weblogic-kubernetes-operator/kubernetes/samples/scripts/create-weblogic-domain/domain-home-on-pv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;디렉토리에서 &lt;strong&gt;create-domain-job-template.yaml&lt;/strong&gt; 파일을 열어 Docker Hub의 &lt;strong&gt;Repository Secret&lt;/strong&gt; 정보를 추가해 준다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;na&quot;&gt;imagePullSecrets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# secret name으로 변경&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mnleecred&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;탬플릿을 저장한 후 도메인 생성을 위한 스크립트를 실행할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;create-domain.sh&lt;/strong&gt;에는 WebLogic Domain 구성 파일들을 &lt;strong&gt;Persistent Volume&lt;/strong&gt;에 만드는 작업을 수행하는 Job을 생성하고 실행하는 부분이 들어가 있다. 이 Job에서는 Docker Hub의 &lt;strong&gt;store/oracle/weblogic:12.2.1.3&lt;/strong&gt; 이미지를 당겨와서 Domain 구성 파일을 만들게 되는데 이 이미지를 Pull하기 위해서는 Docker Hub로 들어가서 &lt;strong&gt;License Agreement&lt;/strong&gt;를 Agree해주는 과정이 먼저 되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/10_proceed_checkout.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/10_proceed_checkout2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/10_proceed_checkout3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;위처럼 pull 커맨드가 보여진 후 도메인 생성 스크립트를 수행한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고 사항
shared 디렉토리의 내용을 확인하기 위해 Public Subnet에 Bastion Host를 하나 생성하고 Shared File System을 Mount하여 내용을 확인해 보면 이해에 도움이 될 것이다.&lt;/p&gt;

  &lt;p&gt;Bastion Host가 생성되었다면 다음 Command를 수행하여 Shared File System을 Mount한다.&lt;/p&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mount 10.0.13.3:/shared /mnt/shared
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
  &lt;p&gt;디렉토리에 아직은 아무 내용도 없는 것을 볼 수 있다.&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/11_empty_shared.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 도메인 생성 스크립트를 실행한다. Job이 수행되고 /shared 디렉토리에 Domain을 생성하고 Job이 종료될 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./create-domain.sh -i create-domain-inputs.yaml -o ./create-domain-output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/12_job_completed.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Job이 잘 수행되었는지는 pod 상태로도 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/12_job_completed2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;이 시점에서 Shared 디렉토리를 살펴보면 Domain 디렉토리와 관련 파일들이 생성되어 있음을 볼 수 있다.&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/13_shared_domain.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;이제 도메인을 기동시켜 보는 단계만 남아있다. 
&lt;strong&gt;create-domain-output&lt;/strong&gt; 디렉토리로 이동하여 다음을 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cd ./create-domain-output/weblogic-domains/domain1
&amp;gt; kubectl apply -f domain.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Admin Server와 Managed Server 두개가 Running 중인 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/13_domain_running.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 과정에서 만들어 둔 LoadBalancer Serivce를 사용해서 외부에서 접속해 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/14_ex_service.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;애플리케이션-배포&quot;&gt;애플리케이션 배포&lt;/h1&gt;

&lt;p&gt;이전 과정에서 처럼 WebLogic Console을 통해 애플리케이션을 Upload하지 않고, &lt;strong&gt;Persistent Volume&lt;/strong&gt;으로 사용하는 domain 디렉토리에 애플리케이션을 복사하고, 모든 Managed Server가 해당 애플리케이션을 바라보도록 배포해 볼 것이다.
먼저 배포할 애플리케이션을 &lt;strong&gt;/shared&lt;/strong&gt;의 특정 위치로 복사한다.&lt;/p&gt;

&lt;p&gt;복사할 때는 Public Subnet에서 구동중인 &lt;strong&gt;Bastion Server&lt;/strong&gt;를 활용하여 공유되고 있는 /shared에 접속하는 방법을 통하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/15_app_copy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;복사가 되어었으면 Admin Server Service의 External IP를 통해 WebLogic Console에 접근하고 애플리케이션을 배포해 보자.
domain 디렉토리 내에 복사해 둔 애플리케이션이 보일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/16_app_deploy1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션을 cluster에 배포하고, 배포 속성 중에 애플리케이션 참조 위치를 특정 디렉토리로 하는 옵션을 선택한 후 애플리케이션 배포를 완료한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/16_app_deploy2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션을 &lt;strong&gt;start&lt;/strong&gt; 시키고, &lt;strong&gt;domain1-cluster1-lb-ext&lt;/strong&gt; 서비스의 External IP를 통해 애플리케이션을 호출해 본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/17_test.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;확장--축소&quot;&gt;확장 / 축소&lt;/h1&gt;

&lt;p&gt;도메인의 Cluster에서 Managed Server의 수를 늘리거나 줄이기 위해서는 다음과 같이 domain을 정보를 수정하면 된다. kubectl의 edit를 이용해서 cluster의 &lt;strong&gt;replica&lt;/strong&gt; 수를 변경해 볼 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; kubectl edit domain domain1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;기본 editor 창으로 들어갈 것이다. replica를 찾아서 수를 변경한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/18_scale1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본 2로 되어있던 수를 3으로 변경하고 저장 (wq)한 후 editor를 빠져 나간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/18_scale2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;domain이 변경되었다.&lt;/p&gt;

&lt;p&gt;잠시 후 pod를 확인하면 domain1-managed-server3이 생성되고 Running 중인 것을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/19_managed3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션에서도 새창을 열어 호출해 보면 새롭게 구동된 managed-server3으로 로드 발란싱 되는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/20_managed3_test.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;로그-확인&quot;&gt;로그 확인&lt;/h1&gt;

&lt;p&gt;Domain 관련 각종 로그들은 /shared/logs 디렉토리에 위치한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic2/21_logs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://oracle.github.io/weblogic-kubernetes-operator/&quot;&gt;Oracle WebLogic Server Kubernetes Operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="WebLogic" /><category term="Kubernetes" /><category term="Oracle Kubernetes Engine" /><category term="Persistent Volume" /><summary type="html">이 전 예제에서는 Docker Image 내에 WebLogic Binary와 Domain 구성 정보가 모두 들어있는 Sample을 이용하였다. 여기서는 WebLogic Binary는 Docker Image 내에 존재 하지만 Domain 정보는 Persistent Volume을 사용하여 외부에 구성하는 예제를 살펴볼 것 이다.</summary></entry><entry><title type="html">WebLogic Operator를 사용하여 Kubernetes에 WebLogic Domain 올리기</title><link href="http://localhost:4000/cloud/2019/k8s-weblogic/" rel="alternate" type="text/html" title="WebLogic Operator를 사용하여 Kubernetes에 WebLogic Domain 올리기" /><published>2019-04-15T00:00:00+09:00</published><updated>2019-04-15T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/k8s-weblogic</id><content type="html" xml:base="http://localhost:4000/cloud/2019/k8s-weblogic/">&lt;p&gt;Oracle WebLogic Server 12c 버전 부터 Kubernetes Cluster에 WebLogic Domain을 쉽게 올릴 수 있도록 하는 &lt;strong&gt;WebLogic Operator&lt;/strong&gt;를 지원하고 있다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 Managed Kubernetes Cloud 서비스인 &lt;strong&gt;Oracle Kubernetes Engine(OKE)&lt;/strong&gt;와 &lt;strong&gt;WebLogic Operator&lt;/strong&gt;를 사용하여 웹로직 도메인을 Provision하는 방법에 대해서 다룰 것이다.&lt;/p&gt;

&lt;h1 id=&quot;architecture&quot;&gt;Architecture&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/arch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;prerequistes&quot;&gt;Prerequistes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Oracle Kubernetes Engine(OKE) : 여기에서는 OKE를 Provision하는 방법에 대해서 다루지 않을 것이다. OKE 프로비전 과정은 다음 문서를 참고한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.oracle.com/webfolder/technetwork/tutorials/obe/oci/oke-full/index.html&quot;&gt;Creating a Cluster with Oracle Cloud Infrastructure Container Engine for Kubernetes&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;oke-접속-확인하기&quot;&gt;OKE 접속 확인하기&lt;/h1&gt;
&lt;p&gt;위 과정을 따라 OKE를 생성하고 Kubeconfig까지 설정하였다고 하면 &lt;strong&gt;kubectl&lt;/strong&gt;을 통해 worker node의 상태를 확인해 본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/01_getnode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OKE&lt;/strong&gt;를 통해 Kubernetes Cluster를 기본 설정으로 구성하면 Private Subnet 안에 Worker Node가 구성되므로 Node IP가 Private IP로 할당된다.&lt;/p&gt;

&lt;h1 id=&quot;weblogic-operator-설치&quot;&gt;WebLogic Operator 설치&lt;/h1&gt;
&lt;p&gt;WebLogic Operator는 &lt;strong&gt;helm&lt;/strong&gt;을 통해 설치 된다.
먼저 WebLogic Operator를 위한 Repository를 추가해 준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm repo add weblogic-operator https://oracle.github.io/weblogic-kubernetes-operator/charts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 추가되었는지 확인해 본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/02_helm_wlsoperator.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;helm을 통해 weblogic-operator를 설치한다 default 설정으로 설치하면 &lt;strong&gt;defaut&lt;/strong&gt; namespace에 설치된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm install weblogic-operator/weblogic-operator --name weblogic-operator --wait
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/02_install_wlsoperator.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;weblogic-image-준비&quot;&gt;WebLogic Image 준비&lt;/h1&gt;

&lt;p&gt;WebLogic Domain을 생성하기 위해서는 WebLogic Server Image가 필요하다. Dockerhub에서 Oracle Certified WebLogic Server Image를 다운 받을 수 있다. 이 이미지를 사용하려면 License Agreement를 Accept 해야 한다. 이 과정을 거치면 이미지를 다운 받는 방법이 보여진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hub.docker.com/u/mnlee30/content/sub-b3c05bc6-7dbf-4e96-ad1c-e8d74a626643&quot;&gt;Oracle WebLogic Server Docker Image&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; docker login 

&amp;gt; docker pull store/oracle/weblogic:12.2.1.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/06_docker_pull_weblogic.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;weblogic-domain-준비&quot;&gt;WebLogic Domain 준비&lt;/h1&gt;

&lt;p&gt;WebLogic Operator를 사용하여 원하는 형태의 WebLogic Domain을 만들어 프로비전 하려면 관련 Kubernetes Configuration File(YAML)이 필요하다.&lt;/p&gt;

&lt;p&gt;WebLogic Operator 사이트에서 몇가지 샘플을 제공하고 있다.
다음을 통해 소스를 받아온다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/oracle/weblogic-kubernetes-operator.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;weblogic-kubernetes-operator/kubernetes/samples/scripts&lt;/strong&gt;에 필요한 Script들이 존재하고 이 스크립트를 통해서 Kubernates configuration 파일을 생성시킬 것이다.&lt;/p&gt;

&lt;p&gt;먼저 도메인 구성에 필요한 &lt;strong&gt;credential&lt;/strong&gt;을 생성한다. 제공된 &lt;strong&gt;create-weblogic-credentials.sh&lt;/strong&gt;을 통해 생성하면 된다. 사용법은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./create-weblogic-credentials.sh -h
usage: ./create-weblogic-credentials.sh -u username -p password [-d domainUID] [-n namespace] [-s secretName] [-h]
  -u username, must be specified.
  -p password, must be specified.
  -d domainUID, optional. The default value is domain1. If specified, the secret will be labeled with the domainUID unless the given value is an empty string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cd scripts/create-weblogic-domain-credentials
&amp;gt; ./create-weblogic-credentials.sh \
   -u weblogic -p welcome1 \
   -d domain1 -n default  \
   -s domain1-weblogic-credentials
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음과 같이 생성 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/05_credential_created.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;kubectl&lt;/strong&gt;로 생성된 secret 정보를 확인해 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/07_desc_secret.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 Domain 생성에 필요한 구성 파일들을 생성할 단계가 되었다.&lt;/p&gt;

&lt;p&gt;여러가지 샘플들 중에서 구성이 가장 간단한 &lt;strong&gt;Domain in a Docker image&lt;/strong&gt; Model를 먼저 사용해 볼 것이다.
해당 디렉토리로 이동하여 &lt;strong&gt;create-domain.sh&lt;/strong&gt;를 수행한다. 사용법은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cd weblogic-kubernetes-operator/kubernetes/samples/scripts/create-weblogic-domain/domain-home-in-image
&amp;gt; ./create-domain.sh \
  -u username \
  -p password \
  -i create-domain-inputs.yaml \
  -o /path/to/output-directory

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/08_createdomain.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진행 사항이 계속 보이고 마지막에 생성된 산출물들의 위치가 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/08_createdomain2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 디렉토리로 이동하여 생성된 산출물의 내용을 한번 확인해 보자&lt;/p&gt;

&lt;p&gt;두개의 파일과 Docker Image가 생성된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/08_createdomain3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;domainyaml-내용&quot;&gt;domain.yaml 내용&lt;/h3&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Copyright 2017, 2019, Oracle Corporation and/or its affiliates. All rights reserved.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Licensed under the Universal Permissive License v 1.0 as shown at http://oss.oracle.com/licenses/upl.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# This is an example of how to define a Domain resource.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;weblogic.oracle/v3&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Domain&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;weblogic.resourceVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain-v2&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;weblogic.domainUID&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# The WebLogic Domain Home&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;domainHome&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/u01/oracle/user_projects/domains/domain1&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# If the domain home is in the image&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;domainHomeInImage&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# The WebLogic Server Docker image that the Operator uses to start the domain&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;domain-home-in-image:12.2.1.3&quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# imagePullPolicy defaults to &quot;Always&quot; if image version is :latest&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;IfNotPresent&quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Identify which Secret contains the credentials for pulling an image&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#imagePullSecrets:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#- name: &lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Identify which Secret contains the WebLogic Admin credentials (note that there is an example of&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# how to create that Secret at the end of this file)&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;webLogicCredentialsSecret&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1-weblogic-credentials&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Whether to include the server out file into the pod's stdout, default is true&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;includeServerOutInPodLog&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Whether to enable log home&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# logHomeEnabled: false&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# The in-pod location for domain log, server logs, server out, and Node Manager log files&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# logHome: /shared/logs/domain1&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# serverStartPolicy legal values are &quot;NEVER&quot;, &quot;IF_NEEDED&quot;, or &quot;ADMIN_ONLY&quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# This determines which WebLogic Servers the Operator will start up when it discovers this Domain&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# - &quot;NEVER&quot; will not start any server in the domain&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# - &quot;ADMIN_ONLY&quot; will start up only the administration server (no managed servers will be started)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# - &quot;IF_NEEDED&quot; will start all non-clustered servers, including the administration server and clustered servers up to the replica count&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;serverStartPolicy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;IF_NEEDED&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;serverPod&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# an (optional) list of environment variable to be set on the servers&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;JAVA_OPTIONS&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-Dweblogic.StdoutDebugEnabled=false&quot;&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;USER_MEM_ARGS&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-Djava.security.egd=file:/dev/./urandom&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-Xms64m&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-Xmx256m&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# volumes:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# - name: weblogic-domain-storage-volume&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#   persistentVolumeClaim:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#     claimName: domain1-weblogic-sample-pvc&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# volumeMounts:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# - mountPath: /shared&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#   name: weblogic-domain-storage-volume&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# adminServer is used to configure the desired behavior for starting the administration server.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;adminServer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# serverStartState legal values are &quot;RUNNING&quot; or &quot;ADMIN&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# &quot;RUNNING&quot; means the listed server will be started up to &quot;RUNNING&quot; mode&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# &quot;ADMIN&quot; means the listed server will be start up to &quot;ADMIN&quot; mode&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;serverStartState&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;RUNNING&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# adminService:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#   channels:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# The Admin Server's NodePort&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#    - channelName: default&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#      nodePort: 30701&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# Uncomment to export the T3Channel as a service&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#    - channelName: T3Channel&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# clusters is used to configure the desired behavior for starting member servers of a cluster.  &lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# If you use this entry, then the rules will be applied to ALL servers that are members of the named clusters.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;clusters&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;clusterName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cluster-1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;serverStartState&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;RUNNING&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# The number of managed servers to start for unlisted clusters&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# replicas: 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 파일에서 &lt;strong&gt;image&lt;/strong&gt; 부분을 수정해 줄 것이다. 현재 Domain Image는 Local Repository에 존재하는데 Cloud의 OKE에서는 내 Local Repository에 접근할 수 없기 때문에, 이 이미지를 Docker Hub에 올려준 후 docker hub의 이미지를 참조하도록 할 것이다.&lt;/p&gt;

&lt;p&gt;먼저 domain.yaml 파일을 수정해 준다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Before&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;domain-home-in-image:12.2.1.3&quot;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# After&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# image: &quot;[dockerhub repository name]/domain-home-in-image:12.2.1.3&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;mnlee30/domain-home-in-image:12.2.1.3&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Domain Image를 Dockerhub에 push 하기 위해 tag를 변경해 준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker tag domain-home-in-image:12.2.1.3 mnlee30/domain-home-in-image:12.2.1.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/09_docker_tag.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;image를 docker hub에 push 한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker push mnlee30/domain-home-in-image:12.2.1.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/10_docker_push.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 domain.yaml을 배포할 준비가 모두 완료되었다.
다음을 수행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f domain.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;kubectl 명령어를 통해 domain이 잘 생성되고 있음을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/11_kubectl_apply.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Admin Server 1개와 Managed Server 2개로 구성된 도메인이 생성되었음을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/12_get_pods.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;service 정보를 확인해 보자. 앞서서 OKE의 Worker Node가 Private Subnet에 생성되었다고 설명하였다.
따라서 WebLogic Instance들을 Node IP로는 접근할 수가 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/13_get_services.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 서비스들을 Load Balancer를 통해 서비스 될 수 있도록 &lt;strong&gt;LoadBalancer&lt;/strong&gt; Type을 사용하는 서비스를 추가해 줄 것이다.
Admin Server(domain1-admin-server)의 콘솔에 접근하기 위한 서비스와 Cluster(domain1-cluster-cluster-1)에 접근하는 서비스가 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;admin-server용-서비스&quot;&gt;Admin Server용 서비스&lt;/h3&gt;

&lt;p&gt;service-admin-lb.yaml 파일을 생성해 준다&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1-admin-lb-ext&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1-admin&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;service.beta.kubernetes.io/oci-load-balancer-shape&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;100Mbps&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;service.beta.kubernetes.io/oci-load-balancer-backend-protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;HTTP&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;6001&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;7001&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;weblogic.serverName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;admin-server&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;weblogic.domainUID&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성된 파일을 적용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f service-admin-lb.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;서비스가 생성되고 EXTERNAL-IP가 할당된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/14_admin_service.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 IP를 이용하여 WebLogic Console에 접근해 본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/15_weblogic_console.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 WebLogic Managed Sever들이 Running 중 임을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/15_weblogic_console2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 도메인에는 어떤 애플리케이션도 배포되어 있지 않기 때문에 Sample Application을 WebLogic Console을 통해 배포 한다.&lt;/p&gt;

&lt;p&gt;배포 과정은 여기서는 생략 한다. 배포된 후의 모습은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/16_application.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cluster용-서비스&quot;&gt;Cluster용 서비스&lt;/h3&gt;

&lt;p&gt;위에서 배포한 애플리케이션을 테스트 해보기 위해서는 weblogic cluster 서비스에 접근해야 한다.
이를 위해 LoadBalancer Type의 서비스를 하나 더 추가해 준다.&lt;/p&gt;

&lt;p&gt;service-cluster-lb.yaml 파일을 생성해 준다&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1-cluster1-lb-ext&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1-cluster1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;service.beta.kubernetes.io/oci-load-balancer-shape&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;100Mbps&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;service.beta.kubernetes.io/oci-load-balancer-backend-protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;HTTP&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;8001&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;weblogic.clusterName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cluster-1&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;weblogic.domainUID&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;domain1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;생성된 파일을 적용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f service-cluster-lb.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/17_cluster_service.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서비스가 생성되고 EXTERNAL-IP가 할당된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;위 IP를 통해서 애플리케이션에 접속해 본다. 
샘플 애플리케이션을 통해 WebLogic Managed Server 명과 구동되고 있는 Pod의 Hostname을 볼수 있다.&lt;/p&gt;

&lt;p&gt;제공된 Session Insert / Update 기능을 통해 세션도 추가해 본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/18_app_test1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;브라우저를 새로 열어 다른 Managed Server에 연결되게 해본다.
라운드 로빈에 의해서 다른 서버에서 요청이 처리되는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubeweblogic/18_app_test2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Saling Up / Down은 다음 글에서 다룰 예정이다.&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://oracle.github.io/weblogic-kubernetes-operator/&quot;&gt;Oracle WebLogic Server Kubernetes Operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="WebLogic" /><category term="Kubernetes" /><category term="Oracle Kubernetes Engine" /><summary type="html">Oracle WebLogic Server 12c 버전 부터 Kubernetes Cluster에 WebLogic Domain을 쉽게 올릴 수 있도록 하는 WebLogic Operator를 지원하고 있다.</summary></entry><entry><title type="html">챗봇 Hands-on Lab (8) - Instant App 구현 및 챗봇 연계</title><link href="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_8/" rel="alternate" type="text/html" title="챗봇 Hands-on Lab (8) - Instant App 구현 및 챗봇 연계" /><published>2019-04-10T00:00:00+09:00</published><updated>2019-04-10T00:00:00+09:00</updated><id>http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87%20Hands-on%20Lab_8</id><content type="html" xml:base="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_8/">&lt;p&gt;챗봇에서 text 기반으로 대화를 주고 받다가, 다수의 정보의 입력이 필요하거나 다양한 포맷의 응답을 제공해 줄 필요가 있을때는 웹 애플리케이션에서 익숙하게 사용하는 Form 형태의 인터페이스가 필요할 경우가 있습니다. 이렇게 필요시에만 앱의 형태 처럼 접근하게 해주고 다시 대화형 인터페이스로 돌아갈 수 있게 해주는 형태를 &lt;strong&gt;Instant App&lt;/strong&gt;이란 용어로 부르고 있는데, 이번 Lab에서는 Instant App을 만들고 챗봇에서 연결하는 방법에 대해서 실습할 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;instant-app-생성&quot;&gt;Instant App 생성&lt;/h1&gt;

&lt;h2 id=&quot;미리-만들어둔-instant-app-파일-다운-받기&quot;&gt;미리 만들어둔 Instant App 파일 다운 받기&lt;/h2&gt;

&lt;p&gt;챗봇의 &lt;strong&gt;Instant App Builder&lt;/strong&gt;에서 새롭게 Instant App을 처음부터 생성할 수 있으나, 이 Lab에서는 기존에 생성된 Instant App을 Import 받아서 항목을 수정하는 형태로 진행할 예정입니다.&lt;/p&gt;

&lt;p&gt;다음에서 설문을 수행하는 Instant App인 Survey 앱 (&lt;strong&gt;survey.json&lt;/strong&gt;) 파일을 다운 받습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://raw.githubusercontent.com/mee-nam-lee/chatbot_lecture/master/labfiles/instantapp/survey.json&quot;&gt;Survey Instant App 다운로드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;instant-app-builder에서-import-하기&quot;&gt;Instant App Builder에서 Import 하기&lt;/h2&gt;

&lt;p&gt;챗봇 콘솔로 이동합니다. 상단 메뉴의 &lt;strong&gt;Instant Apps&lt;/strong&gt;를 클릭하여 Instant App Builder 화면으로 이동합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/01_instant.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Add Instant App&lt;/strong&gt;을 클릭하여 다운받아 둔 survey.json을 import 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/02_import.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Schema File&lt;/strong&gt; 항목에 survey.json을 끌어다 놓으면 Import가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/03_upload.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Import 후에는 해당 Instant App의 Edit 화면으로 바로 이동합니다.
좌측 메뉴에서 &lt;strong&gt;INSTANT APP INFO&lt;/strong&gt;를 클릭하여 &lt;strong&gt;API ID&lt;/strong&gt;를 확인 합니다. 이 API ID는 챗봇에서 Instant App을 호출할 때 사용됩니다.
&lt;strong&gt;Save&lt;/strong&gt; 버튼을 클릭하여 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/04_survey.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 앱이 어떤 기능이 있는지 챗봇과 연계 전에 &lt;strong&gt;Instant App Builder&lt;/strong&gt;에서 바로 테스트 해 볼 수 있습니다.
우측 화면의 &lt;strong&gt;Test&lt;/strong&gt; 탭을 클릭하고 모바일 화면 하단의 &lt;strong&gt;Start as Recipient&lt;/strong&gt;를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/05_test.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;팝업으로 나타나는 &lt;strong&gt;survey: Parameters&lt;/strong&gt; 부분에서는 &lt;strong&gt;OK&lt;/strong&gt;를 눌러주면 됩니다.
서비스 만족도의 별점에 점수에 따라 다른 질문들이 나타납니다. 별점의 점수를 바꿔보세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/06_test1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화면이 어떻게 바뀌는지 확인한 후 화면에 보이는 입력값을을 넣어주고 &lt;strong&gt;설문 완료&lt;/strong&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/07_test2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설문이 완료되고 Confirmation이 보여집니다. Instant App의 Test를 종료하기 위해 &lt;strong&gt;Stop&lt;/strong&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/08_test3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어떤 Component로 이루어진 Instant App인지 좌측의 Layout을 하나씩 살펴보세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/09_layout.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PANE_2&lt;/strong&gt;의 &lt;strong&gt;Add Element&lt;/strong&gt;를 클릭하여 새로운 Element 하나를 더 추가해 보겠습니다.
Content의 &lt;strong&gt;Social Buttons&lt;/strong&gt;를 클릭해서 추가합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/10_edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PREVIEW&lt;/strong&gt;에서 추가된 Element를 바로 확인할 수 있습니다. &lt;strong&gt;Save&lt;/strong&gt;를 클릭하여 변경사항을 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/11_social.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;챗봇에-연결하기&quot;&gt;챗봇에 연결하기&lt;/h1&gt;

&lt;p&gt;이제 Survey Instant App을 챗봇에서 호출해 보도록 하겠습니다.
Flow에서 Instant App을 호출하는 Built-in Component를 이용해야 합니다.&lt;/p&gt;

&lt;p&gt;이 설문 앱을 피자 주문이 완료된 후에 &lt;strong&gt;만족도 평가&lt;/strong&gt;를 위해서 호출하는 형태로 챗봇 Flow를 변경해 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;Flow Edit 화면으로 들어가서 다음 부분을 수정, 추가해 줍니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;na&quot;&gt;Confirmation&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.CommonResponse&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;keepTurn&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;## 추가&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;responseItems&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;주문해&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;주셔서&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;감사합니다.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;주문하신&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;${pizzaSize}&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;${orderedPizza}&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;피자가&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;30분&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;내로&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;배달될&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;예정입니다.&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;text&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;conf&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;separateBubbles&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;attachment&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;attachmentType&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;image&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;image&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;attachmentUrl&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;${orderedPizzaImage}&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;processUserMessage&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;## 변경&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;## 아래는 추가&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;askSurvey&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.List&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;서비스&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;만족도&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;진행&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;중입니다.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;참여하시겠습니까?&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;네&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;yes&quot;&lt;/span&gt; 
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;아니요&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;no&quot;&lt;/span&gt; 
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;actions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;yes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;doSurvey&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;thankyou&quot;&lt;/span&gt;      

  &lt;span class=&quot;na&quot;&gt;thankyou&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.Output&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;감사합니다.&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;done&quot;&lt;/span&gt;

  &lt;span class=&quot;na&quot;&gt;doSurvey&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.Interactive&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;sourceVariableList&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;dummy&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;survey2&quot;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;## Instant App의 API ID를 사용합니다.&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;설문을&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;진행합니다.&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;linkLabel&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;설문으로&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;바로가기&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;textOnlyResponse&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
   
  &lt;span class=&quot;na&quot;&gt;surveyOutput&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.Output&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;${dummy.value.result}&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;done&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Flow 수정 후 상단의 &lt;strong&gt;Validate&lt;/strong&gt;를 클릭하여 Flow에 오류가 없는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/12_flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;test&quot;&gt;Test&lt;/h1&gt;
&lt;p&gt;Flow가 수정이 완료 되었으면 &lt;strong&gt;Skill Tester&lt;/strong&gt;에서 테스트를 수행해 봅니다.
피자 주문 프로세스를 완료한 후 설문 진행 여부를 묻는 Flow가 나오게 구성되어 있습니다.
&lt;strong&gt;설문으로 바로가기&lt;/strong&gt; 링크를 클릭하면 Instant App으로 이동합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/13_callsurvey.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;브라우저의 다른 탭에서 설문 Instant App이 열립니다. Star Rating의 별점 수에 따라 하단에 보이는 Form이 달라집니다.&lt;br /&gt;
별점을 바꿔가며 Form의 내용을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/14_survey1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/14_survey2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Instant App에서 설문을 완료하고 챗봇으로 돌아옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/14_survey3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설문이 종료되었음을 Instant App으로부터 전달받고 다시 대화가 진행될 수 있는 상태가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/14_survey4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;모바일-앱에서-보기&quot;&gt;모바일 앱에서 보기&lt;/h2&gt;

&lt;p&gt;브라우저 기반의 챗봇에서 Instant App을 호출하면 별도의 Tab으로 이동하여 Instant App이 실행된 후 다시 챗봇이 수행 중인 Tab으로 돌아와야 합니다.
모바일 앱에서 실행 될 때에는 어떻게 동작하는지 모바일 앱에서도 확인 해 보세요.&lt;/p&gt;

&lt;p&gt;설문 완료 후 앱의 돌아가기를 클릭하면 모바일 챗봇으로 돌아갑니다.
&lt;img src=&quot;/assets/images/chatbot_lecture/instantapp/20_mobile1.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이상으로 Instant App 구현 과정을 완료하였습니다.&lt;/p&gt;

&lt;h1 id=&quot;chatbot-workshop-lab&quot;&gt;Chatbot-Workshop Lab&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_1/&quot;&gt;챗봇 Hands-on Lab (1) - Lab 개요&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_2/&quot;&gt;챗봇 Hands-on Lab (2) - 금융봇을 이용하여 챗봇 기본 기능 익히기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_3/&quot;&gt;챗봇 Hands-on Lab (3) - 피자봇 만들기 &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_4/&quot;&gt;챗봇 Hands-on Lab (4) - [채널 연결] Web Chat 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_5/&quot;&gt;챗봇 Hands-on Lab (5) - [채널 연결] Mobile 앱 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_6/&quot;&gt;챗봇 Hands-on Lab (6) - Insights(분석) 기능 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_7/&quot;&gt;챗봇 Hands-on Lab (7) - Custom Component 구현하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_8/&quot;&gt;챗봇 Hands-on Lab (8) - Instant App 구현 및 챗봇 연계&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="chatbot" /><category term="오라클 챗봇" /><category term="Hands-on-Lab" /><category term="Instant App" /><summary type="html">챗봇에서 text 기반으로 대화를 주고 받다가, 다수의 정보의 입력이 필요하거나 다양한 포맷의 응답을 제공해 줄 필요가 있을때는 웹 애플리케이션에서 익숙하게 사용하는 Form 형태의 인터페이스가 필요할 경우가 있습니다. 이렇게 필요시에만 앱의 형태 처럼 접근하게 해주고 다시 대화형 인터페이스로 돌아갈 수 있게 해주는 형태를 Instant App이란 용어로 부르고 있는데, 이번 Lab에서는 Instant App을 만들고 챗봇에서 연결하는 방법에 대해서 실습할 것입니다.</summary></entry><entry><title type="html">챗봇 Hands-on Lab (7) - Custom Component 구현하기</title><link href="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_7/" rel="alternate" type="text/html" title="챗봇 Hands-on Lab (7) - Custom Component 구현하기" /><published>2019-04-09T00:00:00+09:00</published><updated>2019-04-09T00:00:00+09:00</updated><id>http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87%20Hands-on%20Lab_7</id><content type="html" xml:base="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_7/">&lt;p&gt;커스텀 비즈니스 로직을 챗봇에 추가하기 위해서는 Node.js 기반의 챗봇 SDK를 사용하여 Custom 로직을 구현하여야 합니다. 이 Lab에서는 지금까지 만든 챗봇에 Custom Component를 구현하여 연결해 볼 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;prerequisite&quot;&gt;Prerequisite&lt;/h1&gt;
&lt;p&gt;기본적으로 커스텀 코드 작성을 위해서 각자의 로컬 환경에 개발툴과 Node.js, 챗봇 SDK를 설치하여 구현하여야 하지만 이 실습 과정에서는 개별 로컬 개발 환경 설정 과정을 생략하기 위해여 Cloud 기반의 소스 관리 및 빌드 기능을 이용하여 코드를 수정해 보는 과정으로 진행하도록 하겠습니다.
이를 위해서 &lt;strong&gt;Oracle Developer Cloud&lt;/strong&gt;를 이용할 것이고, Developer Cloud 서비스 계정과 접속 정보가 제공될 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;developer-cloud-접속--project생성&quot;&gt;Developer Cloud 접속 / Project 생성&lt;/h1&gt;

&lt;p&gt;제공된 접속 정보와 계정 정보로 Developer Cloud에 접속합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/01_devcs_login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create&lt;/strong&gt; 버튼을 클릭하여 커스텀 코드를 관리하고 빌드할 &lt;strong&gt;Project&lt;/strong&gt;를 각자 하나씩 생성할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/02_org.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각자에게 부여된 &lt;strong&gt;Project 명&lt;/strong&gt;을 이용하여 Project를 생성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Project Name : chatbot_{SEQ}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Next&lt;/strong&gt;를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/03_project1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Initial Repository&lt;/strong&gt; 옵션을 선택하고 &lt;strong&gt;Next&lt;/strong&gt;를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/04_project2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Import existing repository&lt;/strong&gt; 옵션을 선택하고 text box에 다음 repository url을 입력합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;repository url : https://github.com/mee-nam-lee/chatbot_component.git&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;입력이 완료되었으면 &lt;strong&gt;Finish&lt;/strong&gt;를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/05_project3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 Project에 필요한 컴포넌트들이 Provision 되는 것이 보일 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/06_project4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Project 생성이 완료되면 자동으로 Project Home 화면으로 이동됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/07_project5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;custom-code-이해하기&quot;&gt;Custom Code 이해하기&lt;/h1&gt;

&lt;p&gt;이 Project는 챗봇의 Custom Code를 외부 Repository로부터 가져왔기 때문에 &lt;strong&gt;Git&lt;/strong&gt; 메뉴로 이동하면 해당 코드들을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/08_git.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Custom Component의 Main Component 코드는 다음 경로에 있습니다. 아래 경로로 이동해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/09_src.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ListStores.js&lt;/strong&gt;와 &lt;strong&gt;StoreService.js&lt;/strong&gt;가 custom component에서 사용하는 코드 입니다.&lt;/p&gt;

&lt;h2 id=&quot;liststorejs&quot;&gt;ListStore.js&lt;/h2&gt;
&lt;p&gt;검색 조건으로 입력된 &lt;strong&gt;location&lt;/strong&gt; 파라미터를 store 정보의 address와 비교하여 검색 조건을 주소에 포함하고 있는 store 정보만을 Card Layout 형태로 만들어서 Reply 해주는 컴포넌트 입니다.&lt;/p&gt;

&lt;h2 id=&quot;storeservicejs&quot;&gt;StoreService.js&lt;/h2&gt;
&lt;p&gt;stores.json에 미리 저장되어 있는 store 정보들 중에서 검색 조건 (location) 기반으로 필터하여 해당 조건에 맞는 store 정보만 리턴하는 컴포넌트 입니다.&lt;/p&gt;

&lt;h1 id=&quot;build-구성하기&quot;&gt;Build 구성하기&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Builds&lt;/strong&gt; 메뉴로 들어가서 &lt;strong&gt;Create Job&lt;/strong&gt;을 클릭하여 Build Job을 하나 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/10_createjob.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 입력하고 &lt;strong&gt;Software Template&lt;/strong&gt; 항목에서 미리 구성되어있는 &lt;strong&gt;node.js&lt;/strong&gt; 탬플릿을 선택한 후 &lt;strong&gt;Create Job&lt;/strong&gt;을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/11_createjob.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Job이 생성되고 나면 Job Configuration 화면으로 이동됩니다. &lt;strong&gt;Source Control&lt;/strong&gt; 탭에서 빌드 대상의 Source가 들어 었는 Repository를 지정하기 위해서 우측의 &lt;strong&gt;Add Source Control&lt;/strong&gt;을 클릭하여 List되는 &lt;strong&gt;Git&lt;/strong&gt;을 선택해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/12_addsource.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Repository&lt;/strong&gt; 항목에서 이미 구성 되어있는 chatbot{SEQ}.git repository를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/13_selectrepo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Steps&lt;/strong&gt; 탭으로 이동하여 Build Step을 추가합니다. node.js로 개발된 소스에 필요한 package를을 설치하고 archiving하기 위해서 &lt;strong&gt;Unix Shell&lt;/strong&gt; Build Executor를 선택하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/14_addstep.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Script&lt;/strong&gt; 입력 부분에 다음 3줄을 입력합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd src
npm install
npm pack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/15_npm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빌드된 Artifact를 저장하기 위한 post build 작업이 필요하기 때문에 &lt;strong&gt;Post Build&lt;/strong&gt; 탭으로 이동합니다.
&lt;strong&gt;Add Post Build Action&lt;/strong&gt; 메뉴에서 &lt;strong&gt;Artifact Archiver&lt;/strong&gt;를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/16_postbuild.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Archive할 파일을 다음과 같이 입력합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Files to archive : src/*.tgz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Save&lt;/strong&gt;를 클릭하여 구성된 내용을 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/17_tgz.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상단의 &lt;strong&gt;Build Now&lt;/strong&gt;를 클릭하면 구성된 내용으로 Build 작업이 시작됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/18_buildnow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Build가 큐잉되고 실제 Build가 수행될 Runtime VM 환경이 준비되는 것을 기다리고 있습니다. VM이 할당되면 Build가 시작 될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/19_queue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빌드가 완료되면 각 빌드 번호별 상태를 아이콘으로 표시해 줍니다. 초록색 아이콘이 보이면 빌드가 정상적으로 완료된 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/20_ builddone.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Actions&lt;/strong&gt;의 아이콘을 클릭하여 빌드 상세 로그를 아리처럼 볼 수 있습니다. 빌드 로그에서도 빌드 과정이 잘 수행되었음을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/21_buildlog.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빌드된 Artifact는 &lt;strong&gt;Artifact&lt;/strong&gt; 메뉴클 클릭하여 확인할 수 있습니다. 아이콘을 클릭하여 들어갑니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/22_artifact.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;src&lt;/strong&gt; 폴더 모양의 아이콘을 클릭하면 component 압축 파일이 보일 것입니다. 이 파일은 Chatbot에 등록하여 서비스될 파일이기 때문에 파일명을 클릭하여 다운로드 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/23_artifact_tgz.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음처럼 다운된 파일을 잘 보관해 둡니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/24_download.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;챗봇에서-custom-component-등록하기&quot;&gt;챗봇에서 Custom Component 등록하기&lt;/h1&gt;

&lt;p&gt;이제 개발된 Custom Component를 챗봇에서 사용하기 위하여 Chatbot 화면으로 이동해 옵니다.&lt;/p&gt;

&lt;p&gt;각자의 &lt;strong&gt;PizzaBot_{SEQ}&lt;/strong&gt;을 엽니다. 좌측 메뉴의 Function 메뉴를 선택하고 &lt;strong&gt;+Service&lt;/strong&gt;를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/25_addservice.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서비스명을 &lt;strong&gt;store&lt;/strong&gt;로 입력하고 &lt;strong&gt;Embedded Container&lt;/strong&gt; 옵션을 선택합니다.
Package File 부분에 이전 단계에서 다운로드 받아둔 Archive를 업로드 하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/26_createservice.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Upload가 되면 다음과 같이 보입니다. &lt;strong&gt;Create&lt;/strong&gt;를 클릭하여 서비스 등록을 완료합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/27_upload.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서비스 생성이 되고 나면 서비스 상태가 &lt;strong&gt;Ready&lt;/strong&gt;가 되며 등록된 Component가 좌측에 보이게 됩니다. &lt;strong&gt;ListStores&lt;/strong&gt;라는 custom component를 챗봇 flow에서 호출하여 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/component/28_servicecreated.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;챗봇에-영업점-조회-추가하기&quot;&gt;챗봇에 영업점 조회 추가하기&lt;/h1&gt;

&lt;p&gt;영업점을 조회하는 &lt;strong&gt;ListStores&lt;/strong&gt;라는 custom component를 챗봇에 추가해 보도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;intent-추가&quot;&gt;Intent 추가&lt;/h2&gt;

&lt;p&gt;현재는 영업점 조회를 위한 intent가 등록되어 있지 않습니다.&lt;/p&gt;

&lt;p&gt;Intent Import를 위해 다음 파일을 다운 받습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://raw.githubusercontent.com/mee-nam-lee/chatbot_lecture/master/labfiles/intent/liststore-Intent.csv&quot;&gt;ListStore Intent 다운받기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;피자봇으로 이동하여 &lt;strong&gt;Intent&lt;/strong&gt; 탭을 선택한 후 &lt;strong&gt;Import Intent&lt;/strong&gt;를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/01_importintent.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 단계에서 다운로드 받은 &lt;strong&gt;liststore-Intent.csv&lt;/strong&gt; 파일을 Import 합니다.&lt;/p&gt;

&lt;p&gt;Intent가 Import 되고 나면 &lt;strong&gt;listStore&lt;/strong&gt; intent가 아래처럼 보이게 될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/02_imported.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우측 상단의 &lt;strong&gt;Train&lt;/strong&gt; 메뉴를 클릭하여 새롭게 추가된 Intent를 학습시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/03_train.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Try It Out&lt;/strong&gt;을 클릭하여 새롭게 추가된 Intent가 잘 동작하는 테스트 해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/04_tryitout.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 Intent Resolution이 잘 테스트 된다면 이제 Flow 수정 단계로 넘어갑니다.&lt;/p&gt;

&lt;h2 id=&quot;flow-수정&quot;&gt;Flow 수정&lt;/h2&gt;

&lt;p&gt;Flow Icon을 클릭하여 Flow 수정 화면으로 이동합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/05_flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Intent State에 다음을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;na&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.Intent&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;iresult&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;actions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;unresolvedIntent&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Unresolved&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;OrderPasta&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;OrderPasta&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ShowMenu&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;ShowMenu&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;OrderPizza&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;OrderPizza&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;CancelPizza&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;CancelPizza&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;listStore&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;listStore&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 추가해 주세요&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/06_intentstate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Confirmation&lt;/strong&gt; State 아래에 다음 state를 추가해 줍니다.&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;na&quot;&gt;listStore&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.Text&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;검색하고자하는&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;영업점의&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;위치를&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입력하세요&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;예:삼성,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;잠실&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;location&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
    
  &lt;span class=&quot;na&quot;&gt;listStoreResult&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;ListStores&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;${location}&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;done&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/07_liststorestate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우측 상단의 &lt;strong&gt;Validate&lt;/strong&gt;를 클릭하여 Flow에 오류가 없나 확인 합니다.&lt;/p&gt;

&lt;h2 id=&quot;test&quot;&gt;Test&lt;/h2&gt;
&lt;p&gt;이제 작성된 로직을 테스트 해 보도록 하겠습니다.
&lt;strong&gt;Skill Tester&lt;/strong&gt; 아이콘을 클릭하여 Test 창을 엽니다.
아래와 같이 &lt;strong&gt;listStore&lt;/strong&gt; intent에 해당하는 utterance를 입력합니다. 
찾고자 하는 위치 정보를 입력해 주고, 원하는 결과가 나오는지 확인 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/08_Test.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;custom-component-수정-하기&quot;&gt;Custom Component 수정 하기&lt;/h1&gt;

&lt;p&gt;이 단계에서는 Custom Component 로직의 수정이 필요할 경우를 가정하여 로직 변경 후 반영하는 방법에 대해서 실습해 보겠습니다.&lt;/p&gt;

&lt;p&gt;영업정 조회 결과로 나오는 링크 버튼의 label을 수정해야 하는 상황이라고 가정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/09_label.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;developer-cloud에서-소스-수정-후-빌드&quot;&gt;Developer Cloud에서 소스 수정 후 빌드&lt;/h2&gt;

&lt;p&gt;소스 코드 수정을 위해 Source Repository로 사용하고 있는 Developer Cloud로 이동합니다.
각자 생성한 Project로 이동하여 &lt;strong&gt;Git&lt;/strong&gt; 메뉴에서 ListStores.js 파일을 찾아 갑니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/10_dev_liststore.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우측 상단의 &lt;strong&gt;Edit&lt;/strong&gt; 아이콘을 클릭하여 Edit Mode로 변경합니다. 아래 Label 내용이 들어있는 부분을 다른 Label로 변경해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/11_edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래와 같이 코드를 수정하고 우측 상단의 &lt;strong&gt;Commit&lt;/strong&gt;을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/12_codeupdate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Confirmation 화면에서 &lt;strong&gt;Commit&lt;/strong&gt;을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/13_commit_confirm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;소스 코드 변경 시 자동으로 Build Job을 수행 시키는 Trigger 설정을 해 두지 않았기 때문에 명시적으로 빌드를 수행시켜줘야 합니다.
&lt;strong&gt;Build&lt;/strong&gt; 메뉴로 이동하여 우측의 삼각형 모양의 Build 아이콘을 클릭해 주면 Build Job이 시작됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/14_build.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Build Job이 큐잉 되었습니다. 빌드 작업이 완료되기를 기다린 후 위 단계에서 했던 것처럼 빌드 산출물(Artifact)를 다운 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/15_buildqueue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Artifacts&lt;/strong&gt;로 이동하여 최종 빌드 산출물을 다운 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/16_artifact.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;산출물 링크를 클릭하여 다운 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/17_download.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;챗봇에서-custom-component-파일-update&quot;&gt;챗봇에서 Custom Component 파일 Update&lt;/h2&gt;

&lt;p&gt;다운 받은 산출물을 반영하기 위하여 챗봇의 Custom Service 등록 화면으로 이동 합니다.&lt;/p&gt;

&lt;p&gt;등록되어 있는 &lt;strong&gt;Store&lt;/strong&gt; 서비스의 &lt;strong&gt;Package File&lt;/strong&gt;을 Update하기 위해 &lt;strong&gt;Change&lt;/strong&gt; 링크를 클릭해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/18_change.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음처럼 변경된 Package가 반영되고 있는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/19_package.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서비스의 &lt;strong&gt;Status&lt;/strong&gt;가 &lt;strong&gt;Ready&lt;/strong&gt;가 될 때까지 기다린 후 다시 챗봇을 Test 해 봅니다.
다음처럼 변경된 Label이 보이는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/liststore/20_afterupdate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이상으로 Custom Component 구현 과정을 완료하였습니다.&lt;/p&gt;

&lt;h1 id=&quot;chatbot-workshop-lab&quot;&gt;Chatbot-Workshop Lab&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_1/&quot;&gt;챗봇 Hands-on Lab (1) - Lab 개요&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_2/&quot;&gt;챗봇 Hands-on Lab (2) - 금융봇을 이용하여 챗봇 기본 기능 익히기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_3/&quot;&gt;챗봇 Hands-on Lab (3) - 피자봇 만들기 &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_4/&quot;&gt;챗봇 Hands-on Lab (4) - [채널 연결] Web Chat 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_5/&quot;&gt;챗봇 Hands-on Lab (5) - [채널 연결] Mobile 앱 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_6/&quot;&gt;챗봇 Hands-on Lab (6) - Insights(분석) 기능 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_7/&quot;&gt;챗봇 Hands-on Lab (7) - Custom Component 구현하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_8/&quot;&gt;챗봇 Hands-on Lab (8) - Instant App 구현 및 챗봇 연계&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="chatbot" /><category term="오라클 챗봇" /><category term="Hands-on-Lab" /><category term="Custom Component" /><summary type="html">커스텀 비즈니스 로직을 챗봇에 추가하기 위해서는 Node.js 기반의 챗봇 SDK를 사용하여 Custom 로직을 구현하여야 합니다. 이 Lab에서는 지금까지 만든 챗봇에 Custom Component를 구현하여 연결해 볼 것입니다.</summary></entry><entry><title type="html">챗봇 Hands-on Lab (6) - Insights(분석) 기능 사용하기</title><link href="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_6/" rel="alternate" type="text/html" title="챗봇 Hands-on Lab (6) - Insights(분석) 기능 사용하기" /><published>2019-04-03T00:00:00+09:00</published><updated>2019-04-03T00:00:00+09:00</updated><id>http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87%20Hands-on%20Lab_6</id><content type="html" xml:base="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_6/">&lt;p&gt;이 Lab에서는 지금까지 만든 챗봇에 분석 기능을 추가해 볼 것 입니다.&lt;/p&gt;

&lt;h1 id=&quot;insights-분석-기능-활성화&quot;&gt;Insights (분석 기능 활성화)&lt;/h1&gt;
&lt;p&gt;오라클 챗봇에는 내장된 분석 기능이 있습니다. 이 기능을 사용하려면 &lt;strong&gt;Enable Insight&lt;/strong&gt;를 선택하여 명시적으로 활성화 해주어야 합니다.&lt;/p&gt;

&lt;p&gt;설정 메뉴를 선택하여 아래와 같이 &lt;strong&gt;Enable Insights&lt;/strong&gt;를 활성화 해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/01_enable_insight.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;활성화 후 바로 Insights 메뉴로 이동하면 분석 내용을 볼 수 있습니다. Insights가 활성화 되고 나서 수행된 대화가 없기 때문에 아직은 수집된 내용이 없을 것입니다.&lt;/p&gt;

&lt;p&gt;이전 Lab에서 연결한 채널을 (Web / Mobile) 이용하여 챗봇과 수차례 대화를 진행합니다.&lt;/p&gt;

&lt;p&gt;Insights 내용을 Refresh 하면 분석된 내용이 보이기 시작합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/02_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/03_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intents&lt;/strong&gt; 탭으로 이동하면 어떤 Intent가 어떤 경로로 수행되었는지 볼 수 있습니다.
Intent List에 구현된 Intent들이 다 나오지 않는다면, &lt;strong&gt;해당 Intent에 해당하는 Utterance를 이용&lt;/strong&gt;하여 대화를 더 시도해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/04_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conversation&lt;/strong&gt; 탭에서 그동안 수행되었던 대화 내용을 확인 할 수 있습니다. 테스트한 대화 내용이 보여지는지 확인 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/05_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;View Conversation&lt;/strong&gt;을 클릭하여 대화 내용을 채팅창에서 확인할 수도 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;이 창에서는 실제 채팅창에서 보여지는 Layout으로 보여지는 것은 아니기 때문에 진행된 대화 흐름을 이해하는 용도라고 이해하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/06_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Retrainer&lt;/strong&gt; 탭으로 이동합니다. 이 메뉴에서는 Intent Resolution에 대한 결과를 조건절을 이용해서 검색해 볼 수 있습니다. &lt;strong&gt;unresolvedIntent&lt;/strong&gt;가 있나 확인합니다. 해당 조건에 맞는 내용이 없다면 채팅창을 이용하여 대화를 더 시도해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/07_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 예시에서는 &lt;strong&gt;안녕&lt;/strong&gt;이라는 Utterance가 unresolvedIntent에 해당된 것을 볼 수 있습니다. 이 Utterance를 Intent의 Sample Data로 사용하고 싶다면 바로 적용할 Intent를 선택한 후 &lt;strong&gt;Add Example&lt;/strong&gt;을 수행하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/08_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;채팅창에서 다시 &lt;strong&gt;안녕&lt;/strong&gt; 이라고 대화를 해보면 이제 메뉴가 보여지게 될 것입니다.&lt;/p&gt;

&lt;p&gt;다음과 같이 &lt;strong&gt;Win Margin&lt;/strong&gt;으로도 검색해 봅니다. Win Margin이 60% 이하 인것을 조회합니다.
해당 검색 결과에서 Intent에 새롭게 추가하고자 하는 Utterance가 있다면 위의 방법 처럼 &lt;strong&gt;Add Example&lt;/strong&gt;을 하게 되면 바로 적용이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/09_insights.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;intent-quality-report&quot;&gt;Intent Quality Report&lt;/h1&gt;

&lt;p&gt;챗봇의 Intent를 학습 시키다 보면 비슷한 Sample Data들이 서로 다른 Intent들에 포함되어 Intent간의 구분/구별을 명확하게 하지 못하게 되는 경우가 있습니다. 이 때문에 챗봇의 정확도가 감소하게 될 수 있는데, 이 Intent의 품질을 검사해 주는 기능을 활용하면 챗봇의 정확도를 개선하는데 도움이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quality&lt;/strong&gt; 메뉴를 클릭하여 Report 생성 화면으로 이동합니다. &lt;strong&gt;Run Report&lt;/strong&gt; 버튼을 클릭하여 Report 생성 작업을 시작 시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/10_runreport.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잠시 후 Report가 나타나면 다음과 같이 Conflict이 있을 수 있는 Intent들을 보여줍니다. 빨간색 경고에 해당하는 Intent를 살펴봐야 합니다. 아래 결과는 &lt;strong&gt;“주문”&lt;/strong&gt; / &lt;strong&gt;“주문 취소”&lt;/strong&gt;가 유사한 Utterance이지만 서로 다른 Intent에 속해 있어 Accuracy가 떨어질 수 있음을 보여주고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/insights/11_reportresult.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이상으로 과정을 완료하였습니다.&lt;/p&gt;

&lt;h1 id=&quot;chatbot-workshop-lab&quot;&gt;Chatbot-Workshop Lab&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_1/&quot;&gt;챗봇 Hands-on Lab (1) - Lab 개요&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_2/&quot;&gt;챗봇 Hands-on Lab (2) - 금융봇을 이용하여 챗봇 기본 기능 익히기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_3/&quot;&gt;챗봇 Hands-on Lab (3) - 피자봇 만들기 &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_4/&quot;&gt;챗봇 Hands-on Lab (4) - [채널 연결] Web Chat 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_5/&quot;&gt;챗봇 Hands-on Lab (5) - [채널 연결] Mobile 앱 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_6/&quot;&gt;챗봇 Hands-on Lab (6) - Insights(분석) 기능 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_7/&quot;&gt;챗봇 Hands-on Lab (7) - Custom Component 구현하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_8/&quot;&gt;챗봇 Hands-on Lab (8) - Instant App 구현 및 챗봇 연계&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="chatbot" /><category term="오라클 챗봇" /><category term="Hands-on-Lab" /><category term="Insight" /><summary type="html">이 Lab에서는 지금까지 만든 챗봇에 분석 기능을 추가해 볼 것 입니다.</summary></entry><entry><title type="html">챗봇 Hands-on Lab (5) - [채널 연결] Mobile 앱 연결하기</title><link href="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_5/" rel="alternate" type="text/html" title="챗봇 Hands-on Lab (5) - [채널 연결] Mobile 앱 연결하기" /><published>2019-04-01T00:00:00+09:00</published><updated>2019-04-01T00:00:00+09:00</updated><id>http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87%20Hands-on%20Lab_5</id><content type="html" xml:base="http://localhost:4000/chatbot/2019/%EC%B1%97%EB%B4%87-Hands-on-Lab_5/">&lt;p&gt;이 Lab에서는 지금까지 만든 챗봇을 모바일 앱을 통해 연결하는 실습을 해 볼 것 입니다.&lt;/p&gt;

&lt;h1 id=&quot;모바일android-채널-생성&quot;&gt;모바일(Android) 채널 생성&lt;/h1&gt;
&lt;p&gt;좌측 메인 메뉴의 &lt;strong&gt;Channels&lt;/strong&gt; 메뉴를 선택합니다.
&lt;img src=&quot;/assets/images/chatbot_lecture/channel/01_channel_settings.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;+ Channel&lt;/strong&gt; 버튼을 클릭하여 새로운 채널을 생성하도록 합니다.&lt;/p&gt;

&lt;p&gt;다음과 같이 입력하고 &lt;strong&gt;Create&lt;/strong&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Name : PizzaBot_{SEQ}.Android
    &lt;blockquote&gt;
      &lt;p&gt;본인이 생성한 PizzaBot과 동일 명으로 합니다&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Descrption : 학생이름 = [본인이름]&lt;/li&gt;
  &lt;li&gt;Channel Type : &lt;strong&gt;Android&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/07_android.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 채널이 만들어 진 것을 확인 합니다. 아직 채널이 활성화 된 상태는 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/08_android_after_create.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만든 채널을 각자의 PizzaBot과 연결하기 위해 &lt;strong&gt;Route To&lt;/strong&gt;를 클릭하여 본인의 Bot과 연결되게 합니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 연결되었는지를 확인하고 &lt;strong&gt;Channel Enabled&lt;/strong&gt;를 활성화 시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/09_android_route.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;채널 생성은 완료되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;모바일-앱-다운-받기&quot;&gt;모바일 앱 다운 받기&lt;/h2&gt;
&lt;p&gt;Oracle Digital Assistant는 Android 앱에서 채팅 기능을 사용할 수 있도록 SDK와 샘플 애플리케이션을 제공하고 있습니다.
이 제공되는 샘플 SDK를 다운 받아 앱을 수정하여 빌드하고 배포하여서 테스트 하도록 되어있지만, 이 Lab에서는 미리 미리 빌드된 apk를 제공하여 설치 후 바로 테스트 할 수 있도록 하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;참고--android-용-sample-다운로드&quot;&gt;참고 : Android 용 Sample 다운로드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/topics/cloud/downloads/amce-downloads-4478270.html&quot;&gt;Oracle Digital Assistant (ODA) and Oracle Mobile Cloud (OMC) Downloads&lt;/a&gt; :  &lt;strong&gt;bots-client-sdk-android-samples-19.1.3.0.zip&lt;/strong&gt;을 다운로드 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/en/cloud/paas/digital-assistant/use-chatbot/channels-topic.html#GUID-4B97C781-6972-44B9-A7D3-9F2F57CE09B9&quot;&gt;Android 앱 설정&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;미리-빌드된-샘플-sdk-apk-설치&quot;&gt;미리 빌드된 샘플 SDK APK 설치&lt;/h3&gt;
&lt;p&gt;위 샘플을 빌드한 APK를 다음에서 다운받아 안드로드이 폰에 설치 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mee-nam-lee/chatbot_lecture/raw/master/labfiles/mobilechat/app-release.apk&quot;&gt;ChatSample SDK APK 다운로드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설치 후 앱을 실행 시킵니다. 다음과 같은 화면이 보일 것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/15_android_01.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;방금 전에 만든 채널의 &lt;strong&gt;App ID&lt;/strong&gt;를 아래와 같이 Text Box에 입력한 후 &lt;strong&gt;계속&lt;/strong&gt;을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/16_android_appid.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 화면에서 챗봇과 대화하기를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/17_android_before_chat.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 대화가 바로 이루어지는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/18_android_chat.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;모바일ios-채널-생성&quot;&gt;모바일(iOS) 채널 생성&lt;/h1&gt;

&lt;p&gt;iOS용 모바일 앱을 위한 채널도 하나 생성해  봅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Name : PizzaBot_{SEQ}.iOS
    &lt;blockquote&gt;
      &lt;p&gt;본인이 생성한 PizzaBot과 동일 명으로 합니다&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Descrption : 학생이름 = [본인이름]&lt;/li&gt;
  &lt;li&gt;Channel Type : &lt;strong&gt;iOS&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/10_ios_create.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;채널이 생성되었으면 Route To와 Enabled를 설정해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/11_ios_created.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고--ios-용-sample-다운로드&quot;&gt;참고 : iOS 용 Sample 다운로드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/topics/cloud/downloads/amce-downloads-4478270.html&quot;&gt;Oracle Digital Assistant (ODA) and Oracle Mobile Cloud (OMC) Downloads&lt;/a&gt; : &lt;strong&gt;bots-client-sdk-ios-samples-19.1.3.0.zip&lt;/strong&gt;을 다운로드 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/en/cloud/paas/digital-assistant/use-chatbot/channels-topic.html#GUID-4B97C781-6972-44B9-A7D3-9F2F57CE09B9&quot;&gt;Android 앱 설정&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iOS용 배포 파일은 제공되지 않습니다. 위 샘플 코드를 받아서 iOS XCode Simulator를 통해 시연해 보면 다음과 같이 보여지게 됩니다.&lt;/p&gt;

&lt;p&gt;iOS 앱에서 실행된 화면은 다음과 같습니다. 동일한 방법으로 App ID를 입력해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/12_ios_appid.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chat with your Bot&lt;/strong&gt;을 클릭하여 대화를 시작합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/13_ios_start_chat.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;피자 주문을 해 보면 다음과 같이 보여집니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_lecture/channel/14_ios_chat_pizza.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;과정을 완료하였습니다.&lt;/p&gt;

&lt;h1 id=&quot;chatbot-workshop-lab&quot;&gt;Chatbot-Workshop Lab&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_1/&quot;&gt;챗봇 Hands-on Lab (1) - Lab 개요&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_2/&quot;&gt;챗봇 Hands-on Lab (2) - 금융봇을 이용하여 챗봇 기본 기능 익히기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_3/&quot;&gt;챗봇 Hands-on Lab (3) - 피자봇 만들기 &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_4/&quot;&gt;챗봇 Hands-on Lab (4) - [채널 연결] Web Chat 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_5/&quot;&gt;챗봇 Hands-on Lab (5) - [채널 연결] Mobile 앱 연결하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_6/&quot;&gt;챗봇 Hands-on Lab (6) - Insights(분석) 기능 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_7/&quot;&gt;챗봇 Hands-on Lab (7) - Custom Component 구현하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Hands-on-Lab_8/&quot;&gt;챗봇 Hands-on Lab (8) - Instant App 구현 및 챗봇 연계&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="chatbot" /><category term="오라클 챗봇" /><category term="Hands-on-Lab" /><category term="Channel" /><category term="mobile" /><summary type="html">이 Lab에서는 지금까지 만든 챗봇을 모바일 앱을 통해 연결하는 실습을 해 볼 것 입니다.</summary></entry><entry><title type="html">Oracle IaaS와 Java Cloud Service를 사용하여 멀티 AD에 3 Tier 아키텍쳐 구축하기 (Regional Subnet 사용)</title><link href="http://localhost:4000/cloud/2019/basic-3tier-arch-regional/" rel="alternate" type="text/html" title="Oracle IaaS와 Java Cloud Service를 사용하여 멀티 AD에 3 Tier 아키텍쳐 구축하기 (Regional Subnet 사용)" /><published>2019-03-25T00:00:00+09:00</published><updated>2019-03-25T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/basic-3tier-arch-regional</id><content type="html" xml:base="http://localhost:4000/cloud/2019/basic-3tier-arch-regional/">&lt;p&gt;이전 문서 &lt;a href=&quot;/cloud/2019/basic-3tier-arch/&quot;&gt;Oracle IaaS와 Java Cloud Service를 사용하여 멀티 AD(Availability Domain)에 3 Tier 아키텍쳐 구축하기&lt;/a&gt;에서는 Availablity Domain Specific Subnet을 이용하여 3 Tier 아키텍처를 구축하는 내용을 설명하였는데, Oracle IaaS에서 &lt;strong&gt;Regional Subnet&lt;/strong&gt;이 지원이 추가되었기 때문에, 이전에 설명되었던 내용이 Regional Subnet 기반으로 구축되려면 어떤 부분이 변경되어야 하는지를 이 문서에서 설명하려고 합니다. 
이전 문서에서 설명하였던 과정은 이 문서에서는 모두 생략하고 변경되는 부분만 다루로록 하겠습니다.&lt;/p&gt;

&lt;p&gt;이전의 Availablity Domain Specific Subnet을 이용한 구축 아키텍처는 다음 그림과 같았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Regional Subnet을 이용하게 되면 아키텍처가 다음과 같이 변경될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/regional/architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;network-생성--구성&quot;&gt;Network 생성 / 구성&lt;/h1&gt;

&lt;p&gt;Regional Subnet을 사용하기 때문에, AD별로 별도록 Subnet을 생성할 필요가 없고 따라서 생성해야 할 Subnet 수가 줄어들게 됩니다.
일반적으로 Public Load Balancer와 Web 서버는 별도의 Subnet에 구축하고, Public Load Balancer를 구성할 경우에는 Web Server를 Private Subnet에 구성하도록 권고 되지만, 여기에서는 하나의 Public Subnet을 생성하여 Load Balancer와 Web Server를 같이 두는 형태로 구성하겠습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;구분&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;이름&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Route Table&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Security List&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;VCN_3Tier&lt;/td&gt;
      &lt;td&gt;Default&lt;/td&gt;
      &lt;td&gt;Default&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Subnet&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_WEB&lt;/td&gt;
      &lt;td&gt;PublicRT&lt;/td&gt;
      &lt;td&gt;PublicSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_WAS&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;PrivateSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_DB&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;DBSL&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;vcn-생성&quot;&gt;VCN 생성&lt;/h2&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h2 id=&quot;service-gateway-생성&quot;&gt;Service Gateway 생성&lt;/h2&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h2 id=&quot;internet-gateway-생성&quot;&gt;Internet Gateway 생성&lt;/h2&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h2 id=&quot;security-list-생성--구성&quot;&gt;Security List 생성 / 구성&lt;/h2&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h2 id=&quot;route-table-생성--구성&quot;&gt;Route Table 생성 / 구성&lt;/h2&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h2 id=&quot;subnet-생성--구성&quot;&gt;Subnet 생성 / 구성&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Regional&lt;/strong&gt; Type으로 선택하는 것 외에 나머지 사항들은 이전과 동일합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/regional/create_subnet.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;나머지 Subnet들도 다음 표를 참고하여 생성합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Subnet Type&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;CIDR&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Route Table&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Subnet Access&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Security List&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_WEB&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;REGIONAL&lt;/td&gt;
      &lt;td&gt;10.0.1.0/24&lt;/td&gt;
      &lt;td&gt;PublicRT&lt;/td&gt;
      &lt;td&gt;Public&lt;/td&gt;
      &lt;td&gt;PublicSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_WAS&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;REGIONAL&lt;/td&gt;
      &lt;td&gt;10.0.2.0/24&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;Private&lt;/td&gt;
      &lt;td&gt;PrivateSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_DB&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;REGIONAL&lt;/td&gt;
      &lt;td&gt;10.0.3.0/24&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;Private&lt;/td&gt;
      &lt;td&gt;DBSL&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;bucket-생성&quot;&gt;BUCKET 생성&lt;/h1&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h1 id=&quot;db-생성&quot;&gt;DB 생성&lt;/h1&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h1 id=&quot;jcs-생성&quot;&gt;JCS 생성&lt;/h1&gt;

&lt;p&gt;JCS 생성을 위한 사전 준비사항과 Java Cloud Service Console을 통해 서비스 생성을 위한 JSON 파일을 얻는 과정은 동일합니다.
두 개의 JCS가 &lt;strong&gt;같은 Regional Subnet&lt;/strong&gt;에 속하지만 &lt;strong&gt;서로 다른 Availabilty Domain&lt;/strong&gt;에 속하도록 생성해야 하기 때문에 
JSON에서 같은 &lt;strong&gt;Private Subnet의 OCID&lt;/strong&gt;를 사용하도록 수정하고 서로 다른 &lt;strong&gt;availabilityDomain&lt;/strong&gt;를 사용하도록 변경해 줍니다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;subnet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;VCN_3Tier_Sub_WAS private subnet의 OCID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;생략&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;availabilityDomain&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JCS 별 다른 AD&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;생략&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JSON으로 JCS 서비스를 생성하는 과정은 동일합니다.&lt;/p&gt;

&lt;h1 id=&quot;web-서버-생성-및-설정&quot;&gt;Web 서버 생성 및 설정&lt;/h1&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h1 id=&quot;coherence-설치-및-구성&quot;&gt;Coherence 설치 및 구성&lt;/h1&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h1 id=&quot;jcs에서-coherence-설정&quot;&gt;JCS에서 Coherence 설정&lt;/h1&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h1 id=&quot;애플리케이션-배포&quot;&gt;애플리케이션 배포&lt;/h1&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h1 id=&quot;load-balancer-생성&quot;&gt;Load Balancer 생성&lt;/h1&gt;

&lt;p&gt;Regional Subnet을 사용하는 Public Load Balancer를 생성해 줍니다. Regional Subnet을 선택하게 되면 그 안에서 AD간의 HA는 자동으로 구성되도록 Load Balancer가 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/regional/create_lb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;test&quot;&gt;Test&lt;/h1&gt;
&lt;p&gt;동일&lt;/p&gt;

&lt;h1 id=&quot;이전-문서-참고&quot;&gt;이전 문서 참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/cloud/2019/basic-3tier-arch/&quot;&gt;Oracle IaaS와 Java Cloud Service를 사용하여 멀티 AD(Availability Domain)에 3 Tier 아키텍쳐 구축하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Oracle Cloud" /><category term="Virtual Cloud Network" /><category term="IaaS" /><category term="3 Tier Architecture" /><category term="HA" /><category term="Java Cloud Service" /><summary type="html">이전 문서 Oracle IaaS와 Java Cloud Service를 사용하여 멀티 AD(Availability Domain)에 3 Tier 아키텍쳐 구축하기에서는 Availablity Domain Specific Subnet을 이용하여 3 Tier 아키텍처를 구축하는 내용을 설명하였는데, Oracle IaaS에서 Regional Subnet이 지원이 추가되었기 때문에, 이전에 설명되었던 내용이 Regional Subnet 기반으로 구축되려면 어떤 부분이 변경되어야 하는지를 이 문서에서 설명하려고 합니다. 이전 문서에서 설명하였던 과정은 이 문서에서는 모두 생략하고 변경되는 부분만 다루로록 하겠습니다.</summary></entry><entry><title type="html">Oracle IaaS와 Java Cloud Service를 사용하여 멀티 AD(Availability Domain)에 3 Tier 아키텍쳐 구축하기</title><link href="http://localhost:4000/cloud/2019/basic-3tier-arch/" rel="alternate" type="text/html" title="Oracle IaaS와 Java Cloud Service를 사용하여 멀티 AD(Availability Domain)에 3 Tier 아키텍쳐 구축하기" /><published>2019-03-05T00:00:00+09:00</published><updated>2019-03-05T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/basic-3tier-arch</id><content type="html" xml:base="http://localhost:4000/cloud/2019/basic-3tier-arch/">&lt;p&gt;이 문서에서는 다음과 같은 가장 일반적인 3-Tier 아키텍처 기반의 웹 시스템을 &lt;strong&gt;Oracle Cloud Infrastructure(IaaS)&lt;/strong&gt;와 &lt;strong&gt;Java Cloud Service(PaaS)&lt;/strong&gt;를 이용하여 구축하는 방법에 대해서 기술합니다.&lt;/p&gt;

&lt;p&gt;구축 아키텍처는 다음 그림에서 보여지는 것과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;필요-서비스-및-소프트웨어&quot;&gt;필요 서비스 및 소프트웨어&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Oracle Cloud Infrastructure
    &lt;ul&gt;
      &lt;li&gt;Compute Service&lt;/li&gt;
      &lt;li&gt;Network Service&lt;/li&gt;
      &lt;li&gt;Object Storage Service&lt;/li&gt;
      &lt;li&gt;Database System&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java Cloud Service&lt;/li&gt;
  &lt;li&gt;필요 소프트웨어
    &lt;ul&gt;
      &lt;li&gt;Apache (Open Source)&lt;/li&gt;
      &lt;li&gt;Oracle Coherence&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아키텍처-특징&quot;&gt;아키텍처 특징&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Virtual Cloud Network(VCN)&lt;/strong&gt;을 이용하여 가상 네트워크를 구성&lt;/li&gt;
  &lt;li&gt;두 개의 &lt;strong&gt;Availability Domain(AD)&lt;/strong&gt;를 이용하여 &lt;strong&gt;HA&lt;/strong&gt;가 되도록 구성&lt;/li&gt;
  &lt;li&gt;Java Cloud Service(JCS)와 Database는 &lt;strong&gt;Private Subnet&lt;/strong&gt;에 구성&lt;/li&gt;
  &lt;li&gt;서로 다른 AD에 각기 구성된 JCS 도메인의 &lt;strong&gt;세션 공유는 Coherence Cluster&lt;/strong&gt;를 이용하여 구성&lt;/li&gt;
  &lt;li&gt;웹서버에서는 해당 AD 내의 JCS만 로드 발란싱이 이루어 지도록 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;비고&quot;&gt;비고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;여기서 설명하는 기본 아키텍처에서는 Database 이중화 부분은 고려하지 않음&lt;/li&gt;
  &lt;li&gt;DB 이중화를 위해서는 추가 작업이 필요함&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;network-생성--구성&quot;&gt;Network 생성 / 구성&lt;/h1&gt;

&lt;p&gt;위 아키텍처 구성을 위해 다음과 같은 Virtual Cloud Network(VCN) 구성이 필요합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;구분&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;이름&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Route Table&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Security List&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;VCN_3Tier&lt;/td&gt;
      &lt;td&gt;Default&lt;/td&gt;
      &lt;td&gt;Default&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Subnet&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_Web_AD1&lt;/td&gt;
      &lt;td&gt;PublicRT&lt;/td&gt;
      &lt;td&gt;PublicSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_Web_AD2&lt;/td&gt;
      &lt;td&gt;PublicRT&lt;/td&gt;
      &lt;td&gt;PublicSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_WAS_AD1&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;PrivateSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_WAS_AD2&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;PrivateSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;VCN_3Tier_Sub_DB_AD1&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;DBSL&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;vcn-생성&quot;&gt;VCN 생성&lt;/h2&gt;

&lt;p&gt;VCN을 다음과 같이 생성합니다. Subnet은 두개만 필요하기 때문에 “&lt;strong&gt;Create Virtual Cloud Network Only&lt;/strong&gt;” 옵션을 선택하고 Subnet을 나중에 추가하도록 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;service-gateway-생성&quot;&gt;Service Gateway 생성&lt;/h2&gt;
&lt;p&gt;Private Subnet에서 Public에 존재하는 Oracle Service에 Internet 망을 거치지 않고 Oracle Cloud 내부 네트워크를 통해 접속하게 하기 위해서는 Service Gateway가 필요합니다. 이 Service Gateway를 통해 Object Storage에 연결할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;internet-gateway-생성&quot;&gt;Internet Gateway 생성&lt;/h2&gt;

&lt;p&gt;Public Subnet에서 인터넷 접속을 위해 사용할 Internet Gateway를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;security-list-생성--구성&quot;&gt;Security List 생성 / 구성&lt;/h2&gt;

&lt;p&gt;Subnet을 개별적으로 구성하고 각 Public Subnet / Private Subnet 별로 Route Table과 Security List를 달리 구성해야 하기 때문에 
Subnet 생성 전에 Security List와 Route Table을 미리 구성해 두고 Subnet 생성 시에 미리 만들어진 것들을 이용해야 합니다.&lt;/p&gt;

&lt;p&gt;생성된 VCN의 Security Lists 메뉴로 이동하여 필요한 Security List를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래와 같이 Security List를 생성하고 Ingress/Egress Rule을 추가해 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;public-security-list--publicsl&quot;&gt;Public Security List : PublicSL&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ingress Rules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Egress Rules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;private-security-list--privatesl&quot;&gt;Private Security List : PrivateSL&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ingress Rules&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Public Subnet (10.0.1.0/24, 10.0.2.0/24)으로 부터 들어오는 포트는 22, 80, 8001, 7001이 사용될 것이므로 이 포트를 각각 지정해 줘도 되지만 여기서는 두 Subnet에서부터 들어오는 port는 모두 허용하는 것으로 설정하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Egress Rules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;private-security-list--dbsl&quot;&gt;Private Security List : DBSL&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ingress Rules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Egress Rules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;route-table-생성--구성&quot;&gt;Route Table 생성 / 구성&lt;/h2&gt;

&lt;p&gt;Route Table 메뉴에서 Route Table을 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;public-route-table--publicrt&quot;&gt;Public Route Table : PublicRT&lt;/h3&gt;
&lt;p&gt;Public Route Table에서는 Internet Gateway로 가는 Route를 설정해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;private-route-table--privatert&quot;&gt;Private Route Table : PrivateRT&lt;/h3&gt;
&lt;p&gt;Private Route Table에서는 Object Storage로 가기 위한 Service Gateway로의 Route를 추가해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;subnet-생성--구성&quot;&gt;Subnet 생성 / 구성&lt;/h2&gt;

&lt;p&gt;만들어진 VCN에 들어가서 &lt;strong&gt;Create Subnet&lt;/strong&gt;을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;public-subnet-1--vcn_3tier_sub_web_ad1&quot;&gt;Public Subnet 1 : VCN_3Tier_Sub_Web_AD1&lt;/h3&gt;

&lt;p&gt;Public Subnet을 다음과 같이 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;나머지 Subnet들도 다음 표를 참고하여 생성합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Subnet Type&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;AD&lt;/strong&gt;   &lt;strong&gt;CIDR&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Route Table&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Subnet Access&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Security List&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_Web_AD1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AVAILABILITY DOMAIN-SPECIFIC&lt;/td&gt;
      &lt;td&gt;AD1&lt;/td&gt;
      &lt;td&gt;10.0.1.0/24&lt;/td&gt;
      &lt;td&gt;PublicRT&lt;/td&gt;
      &lt;td&gt;Public&lt;/td&gt;
      &lt;td&gt;PublicSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_Web_AD2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AVAILABILITY DOMAIN-SPECIFIC&lt;/td&gt;
      &lt;td&gt;AD2&lt;/td&gt;
      &lt;td&gt;10.0.2.0/24&lt;/td&gt;
      &lt;td&gt;PublicRT&lt;/td&gt;
      &lt;td&gt;Public&lt;/td&gt;
      &lt;td&gt;PublicSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_WAS_AD1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AVAILABILITY DOMAIN-SPECIFIC&lt;/td&gt;
      &lt;td&gt;AD1&lt;/td&gt;
      &lt;td&gt;10.0.3.0/24&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;Private&lt;/td&gt;
      &lt;td&gt;PrivateSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_WAS_AD2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AVAILABILITY DOMAIN-SPECIFIC&lt;/td&gt;
      &lt;td&gt;AD2&lt;/td&gt;
      &lt;td&gt;10.0.4.0/24&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;Private&lt;/td&gt;
      &lt;td&gt;PrivateSL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VCN_3Tier_Sub_DB_AD1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AVAILABILITY DOMAIN-SPECIFIC&lt;/td&gt;
      &lt;td&gt;AD1&lt;/td&gt;
      &lt;td&gt;10.0.5.0/24&lt;/td&gt;
      &lt;td&gt;PrivateRT&lt;/td&gt;
      &lt;td&gt;Private&lt;/td&gt;
      &lt;td&gt;DBSL&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;bucket-생성&quot;&gt;BUCKET 생성&lt;/h1&gt;

&lt;p&gt;Java Cloud Service(JCS)와 Database System 생성 시에 백업을 위한 Object Storage Bucket이 필요하기 때문에 다른 준비에 앞서서 미리 만들어 두도록 합니다. 특히 JCS에서의 Bucket 사용 관련하여서는 다음과 같은 전제 조건이 있기 때문에 Bucket 생성 시에는 OCI의 IAM 계정을 등록하고 이 계정을 이용하여 Bucket을 생성하도록 합니다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;Bucket 생성은 IDCS Federated User가 아닌 IAM에 등록된 User로 만들어야 하고, 이 계정 정보를 JCS 생성시 Backup Storage Container Credential로 사용한다.&lt;/p&gt;

  &lt;p&gt;The user creating the buckets must be a user in Oracle Cloud Infrastructure Identity and Access Management (IAM), not a federated user.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;JCS에서 사용할 Bucket을 하나 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Database에서 사용할 Bucket을 하나 생성 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;db-생성&quot;&gt;DB 생성&lt;/h1&gt;

&lt;p&gt;OCI 콘솔의 &lt;strong&gt;Bare Metal, VM, and Exadata&lt;/strong&gt; 메뉴로 들어가서 해당하는 Compartment를 선택 후 &lt;strong&gt;Launch DB System&lt;/strong&gt;을 클릭하여 DB를 생성 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Virtual Machine 옵션을 선택 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;미리 생성해 둔 DB용 Subnet을 선택 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;백업 선택은 옵션이니 사용할 경우에는 위에서 생성해 둔 BUCKET 정보를 이용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DB가 잘 생성되었는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jcs-생성&quot;&gt;JCS 생성&lt;/h1&gt;

&lt;p&gt;이 단계에서는 WebLogic 기반의 PaaS 서비스인 Java Cloud Service를 생성하도록 하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;사전-준비-사항&quot;&gt;사전 준비 사항&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;JCS 용 버킷 생성 : 이전 단계에서 생성함&lt;/li&gt;
  &lt;li&gt;PSM(PaaS Service Manager)가 OCI의 리소스를 사용하기 위한 Policy들이 사전 정의 되어야 함 : 아래 Policy를 참고하여 속해 있는 그룹의 Policy에 추가해 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Private Subnet을 사용하는 Java Cloud Service(JCS)는JCS 서비스 콘솔을 통해서 생성할 수가 없습니다. 현재까지는 JCS 콘솔에서는 Public Subnet 만 선택할 수 있게 되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;&lt;strong&gt;&lt;em&gt;참고 문서 :&lt;/em&gt;&lt;/strong&gt; &lt;a href=&quot;https://docs.oracle.com/en/cloud/paas/java-cloud/jscug/create-instance-attached-private-subnet-oci.html#GUID-36EB6099-C792-4017-A4C7-06F796926AF6&quot;&gt;Create an Oracle Java Cloud Service Instance Attached to a Private Subnet on Oracle Cloud Infrastructure&lt;/a&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;따라서 Private Subnet을 이용하는 JCS를 생성하고자 할 경우에는 제공되는 REST API를 이용하거나 PSM(PaaS Service Manager) CLI를 이용해야 하는데. 이 가이드에서는 REST API를 이용하는 방법으로 설명합니다.&lt;/p&gt;

&lt;p&gt;또한 참고문서(매뉴얼)에서 설명하는 방법으로 생성하게 되면 Database System on Oracle Cloud Infrastucture가 아닌 Database Cloud Service (DBCS on OCI-C)가 생성되기 때문에 &lt;strong&gt;Database System on OCI를 이용한 JCS를 생성하고자 한다면 아래 설명을 따라 수행해야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JCS 서비스를 생성하는 REST API는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST https://jaas.oraclecloud.com/paas/api/v1.1/instancemgmt/[IdentityServiceID]/services/jaas/instances \
-u [User Name]:[Password] \
-H 'X-ID-TENANT-NAME: [IdentityServiceID]' \
-H 'Content-Type: application/json' \
-d @requestBodyFile.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 입력 값으로 사용하는 &lt;strong&gt;requestBodyFile.json&lt;/strong&gt;이라는 json의 내용이 복잡하고 많은데, 이는 JCS의 콘솔을 통해서 얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;JSON을 얻기 위해 먼저 JCS 콘솔로 이동하여 &lt;strong&gt;Create Instance&lt;/strong&gt;를 선택하여 Provision을 위한 정보 들을 입력합니다. Subnet List Box에서는 위에서 언급한 것처럼 Public Subnet만 보일 것이기 때문에 보이는 것 중 어느 것이나 선택해도 무방합니다. &lt;strong&gt;향후 JSON을 얻고 나서 Private Subnet을 사용하는 것으로 수정해 줄 것 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advanced&lt;/strong&gt; 옵션을 선택하고 다음과 같이 선택해 줍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Enable Access to Administration Consoles: true&lt;/li&gt;
  &lt;li&gt;Load Balancer: None&lt;/li&gt;
  &lt;li&gt;Oracle Cloud Infrastructure Database : check&lt;/li&gt;
  &lt;li&gt;Compartment Name : 해당 Compartment&lt;/li&gt;
  &lt;li&gt;Database Instance Name : 앞 단계에서 생성해 둔 DB 선택&lt;/li&gt;
  &lt;li&gt;Object Storage Container : JCS 용으로 생성해 둔 Bucket 정보를 입력합니다.
    &lt;ul&gt;
      &lt;li&gt;https://swiftobjectstorage.us-ashburn-1.oraclecloud.com/v1/[TENANT-ID]/[BUCKET-명]&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.cloud.oracle.com/iaas/Content/API/Concepts/apiref.htm&quot;&gt;Region 별 REST API Endpoint 참고&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;예: https://swiftobjectstorage.us-ashburn-1.oraclecloud.com/v1/apackrsct01/jcs_bucket&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Object Storage Password : IAM 계정의 &lt;strong&gt;Auth Token&lt;/strong&gt;을 입력해 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Next&lt;/strong&gt;를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Confirm 화면에서 화살표로 표시된 Input Parameter들이 담긴 &lt;strong&gt;JSON 다운받기&lt;/strong&gt;를 클릭합니다. 이 서비스를 콘솔에서 생성할 것이 아니므로 여기서는 &lt;strong&gt;Cancel&lt;/strong&gt;을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;service_payload_jcs서비스명.json&lt;/strong&gt; 파일이 생성되었을 것 입니다. 이 파일을 앞서 설명한 REST API의 Input Json으로 사용할 것입니다. 이 파일을 열어서 다음에 설명하는 항목들을 변경해 줍니다.&lt;/p&gt;

&lt;p&gt;빨간 박스로 체크해 둔 항목을 수정해 줍니다. Subnet 부분 변경이 핵심이므로 JCS에서 사용할 &lt;strong&gt;Private Subnet의 OCID&lt;/strong&gt;로 변경해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파일 수정이 완료되었으면 위에서 설명한 Create Instance REST API를 수행해 줍니다.&lt;/p&gt;

&lt;p&gt;스크립트로 만들어서 다음과 같이 수행해도 됩니다. API가 수행되면 JOB ID가 다음과 같이 리턴되고, 리턴된 JOB ID로 JOB의 상태를 확인해 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;checkJCSJob.sh 스크립트 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl https://jaas.oraclecloud.com/paas/api/v1.1/activitylog/[identityServiceID]/job/[JOBID] \                                            
-u [usename]:[password] \                                                                            
-H 'X-ID-TENANT-NAME: [identityServiceID]'                                           
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JOB이 실행되고 있는 사항은 JCS 콘솔에서도 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 방법으로 AD1, AD2를 사용하는 WAS 용 Subnet에 각각 한 개씩 JCS 서비스를 생성 합니다.&lt;/p&gt;

&lt;p&gt;다 완성된 모습은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;web-서버-생성-및-설정&quot;&gt;Web 서버 생성 및 설정&lt;/h1&gt;

&lt;p&gt;JCS 서버의 서비스 앞 단에 WEB 서버 인스턴스를 두고 로드 발란싱을 하도록 구성할 것입니다. 웹서비는 어떤 것을 사용하여도 무방합니다.
여기에서는 Apache를 사용하는 것으로 설명합니다.&lt;/p&gt;

&lt;h2 id=&quot;compute-인스턴스-생성&quot;&gt;Compute 인스턴스 생성&lt;/h2&gt;

&lt;p&gt;웹서버는 IaaS Compute 인스턴스에 구성할 것입니다. 따라서 먼저 Compute Instance를 생성합니다.&lt;/p&gt;

&lt;p&gt;AD1과 AD2 에 각각 한개 씩 구성할 예정이므로 먼저 AD1 의 Public Subnet에 인스턴스를 다음과 같이 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image38.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image39.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성되었습니다. SSH로 접속할 Public IP를 기억해 두세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 인스턴스는 첫번 째 인스턴스 구성을 다 완료한 후에 Custom Compute Image로 만들어서 생성할 것입니다.&lt;/p&gt;

&lt;p&gt;그러므로 먼저 첫번째 인스턴스 구성을 먼저 완료하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;생성된 인스턴스의 Public IP를 이용하여 SSH로 접속합니다.&lt;/p&gt;

&lt;h2 id=&quot;apache-설치&quot;&gt;Apache 설치&lt;/h2&gt;

&lt;p&gt;웹서버로 사용할 Apache를 설치하여야 합니다. Yum으로 설치하는 httpd는 shared module이 enabled 된 버전이 아니기 때문에 Apache 소스를 받아서 컴파일하여 설치하는 방법으로 Apache를 설치 해 줍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://httpd.apache.org/docs/2.4/install.html&quot;&gt;Apache 설치 참고 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 저는 다음 옵션을 사용하여 컴파일 하였습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ./configure --prefix=/usr/local/apache --enable-module=so --with-pcre=/usr/local/pcre/bin/pcre-config -enable-rewrite --with-mpm=worker --enable-ssl  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;weblogic-plugin-설치&quot;&gt;WebLogic Plugin 설치&lt;/h2&gt;

&lt;p&gt;Plugin 소프트웨어를 다음에서 다운 받습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/middleware/webtier/downloads/index-jsp-156711.html&quot;&gt;웹로직 플러그인 다운 받기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image41.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다운 받은 zip 파일을 안에는 여러 웹서버 및 OS용 Plugin들이 모두 들어 있습니다. 이 중에서 Linux용 Apache 플러그인 만 웹서버용 Compute 인스턴스로 복사해 줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scp -i privateKey ~/Downloads/fmw_12.2.1.3.0_wlsplugins_Disk1_1of1/WLSPlugins12c-12.2.1.3.0/WLSPlugin12.2.1.3.0-Apache2.2-Apache2.4-Linux_x86_64-12.2.1.3.0.zip opc@[웹서버 Public IP]:/home/opc/wlplugin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;복사된 플러그인 zip 파일의 압축을 풉니다. 아래 라이브러리들 중 mod_wl.so 파일을 사용할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image42.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;apache-구성&quot;&gt;Apache 구성&lt;/h2&gt;

&lt;p&gt;WebLogic Plugin 구성 상세는 다음을 참고하세요&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/middleware/12213/webtier/develop-plugin/apache.htm#PLGWL395&quot;&gt;Configuring the Plug-In for Apache HTTP Server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 가이드에서는 &lt;strong&gt;/usr/local/apache&lt;/strong&gt; 경로에 Apache가 설치되어 있습니다. conf 디렉토리로 이동하여 httpd.conf 파일을 수정해 줍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WebLogicHost&lt;/strong&gt;는 JCS 서비스의 Private IP를 참고하여 변경합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션은 아직 배포되지 않았으나 미리 설정해 둡니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JCS가 Private Subnet에 구성되었기 때문에 현재로서는 웹로직 콘솔을 Internet을 통해서 접속할 수가 없습니다. 따라서 웹서버에서 포워딩하는 형태로 웹로직 콘솔에 접속하기 위하여 &lt;strong&gt;/console 설정도 해 줍니다. 여기서의 WebLogicHost는 웹로직 Admin Server의 Host&lt;/strong&gt;여야 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;s&quot;&gt;... 생략&lt;/span&gt;                                                          
                                                                   
&lt;span class=&quot;c1&quot;&gt;# Weblogic Module 추가                                           &lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;LoadModule weblogic_module /home/opc/wlplugin/lib/mod_wl_24.so&lt;/span&gt; 

&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;생략&lt;/span&gt;  

&lt;span class=&quot;s&quot;&gt;&amp;lt;Location /console&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;WLSRequest On&lt;/span&gt;   
 &lt;span class=&quot;s&quot;&gt;WebLogicHost 10.0.3.2&lt;/span&gt;  
 &lt;span class=&quot;s&quot;&gt;WebLogicPort 7001&lt;/span&gt; 
&lt;span class=&quot;s&quot;&gt;&amp;lt;/Location&amp;gt;&lt;/span&gt; 

&lt;span class=&quot;s&quot;&gt;&amp;lt;Location /cohweb&amp;gt;&lt;/span&gt;   
 &lt;span class=&quot;s&quot;&gt;WLSRequest On&lt;/span&gt;   
 &lt;span class=&quot;s&quot;&gt;WebLogicHost 10.0.3.2&lt;/span&gt; 
 &lt;span class=&quot;s&quot;&gt;WebLogicPort 8001&lt;/span&gt;  
&lt;span class=&quot;s&quot;&gt;&amp;lt;/Location&amp;gt;&lt;/span&gt; 

&lt;span class=&quot;s&quot;&gt;&amp;lt;IfModule mod_weblogic.c&amp;gt;&lt;/span&gt; 
 &lt;span class=&quot;s&quot;&gt;WebLogicHost 10.0.3.2&lt;/span&gt;   
 &lt;span class=&quot;s&quot;&gt;WebLogicPort 8001&lt;/span&gt;  
 &lt;span class=&quot;s&quot;&gt;MatchExpression *.jsp&lt;/span&gt;   
 &lt;span class=&quot;s&quot;&gt;DebugConfigInfo ON&lt;/span&gt;    
&lt;span class=&quot;s&quot;&gt;&amp;lt;/IfModule&amp;gt;&lt;/span&gt;  

&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;생략&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Apache를 구동 시킵니다. Apache가 default로 80 포트로 Listen하고 있는데 해당 Port가 Firewall을 통과할 수 있도록 다음 커맨드를 통해서 등록해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Apache 구성이 완료되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;커스텀-이미지-생성&quot;&gt;커스텀 이미지 생성&lt;/h2&gt;

&lt;p&gt;AD2에서 사용할 Web 서버 인스턴스도 생성해야 합니다. 구성이 완료된 WEB 인스턴스를 Custom Image로 만들어서 Compute Instance를 생성하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image44.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image45.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이미지가 생성되고 나면 이 이미지를 사용하여 Compute Instance를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image47.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AD2의 Subnet을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image48.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Compute Instance가 다 생성되고 나면, SSH로 접속하여 Apache 설정만 변경해 주면 됩니다.&lt;/p&gt;

&lt;p&gt;AD2의 Apache는 AD2 내의 JCS 서비스를 바라보도록 httpd.conf의 WeblogicHost 정보만 바꿔주고 Apache를 기동시켜 줍니다.&lt;/p&gt;

&lt;h1 id=&quot;coherence-설치-및-구성&quot;&gt;Coherence 설치 및 구성&lt;/h1&gt;

&lt;p&gt;이제는 Coherence 구성을 진행하도록 하겠습니다. 
두 AD 간의 두개의 JCS 서비스 간 HTTP Session 공유를 위하여 Coherence를 사용할 예정입니다. JCS 내에도 Managed Coherence 서버를 구성할 수 있지만 서로 다른 WebLogic Domain간의 세션 공유를 위해서 별도의 Coherence Cluster를 구성하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;Coherence 구성을 위해서 두개의 Compute Instance가 필요합니다.&lt;/p&gt;

&lt;p&gt;Coherence용 Compute Instance를 AD1에 먼저 구성한 후 구성이 완료된 후에 WEB의 경우와 마찬가지로 Custom Image를 생성하여 AD2에도 구성하도록 하겠습니다. Coherence는 Private Subnet에 만들어져야 합니다.&lt;/p&gt;

&lt;p&gt;Compute Instance를 만드는 과정을 생략하도록 하겠습니다. 생성되고 난 후의 모습은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인스턴스가 생성된 후 SSH로 Coherence 노드에 접속합니다. Private Subnet에 속해 있기 때문에 WEB 인스턴스를 통해서 Coherence 인스턴스에 접속합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image50.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;coherence-설치&quot;&gt;Coherence 설치&lt;/h2&gt;

&lt;p&gt;Stand alone으로 설치하는 Coherence는 JCS내의 Coherence 버전과 동일해야 합니다. JCS 콘솔에서 WebLogic 버전을 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image51.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동일 버전의 Coherence SW를 다운 받습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/middleware/coherence/overview/index.html&quot;&gt;Coherenc Download&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image52.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Coherence 설치 과정은 다음을 참고하시기 바랍니다. 여기에서는 설치 이후의 설정 과정만 설명하도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/middleware/1212/coherence/COHDG/gs_install.htm#COHDG5660&quot;&gt;Installing Oracle Coherence for Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 가이드에서는 coherence가 다음 위치에 설치 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image53.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Coherence 기동을 위한 스크립트를 작성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Coherence*Web&lt;/strong&gt;을 사용할 것이기 때문에 session cache 설정을 해 줍니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cloud 환경에서 multicast가 지원되지 않기 때문에 &lt;strong&gt;unicast를 사용하는 WKA(Well Known Address)&lt;/strong&gt;를 설정해 줍니다. WKA 상세 설명과 여러 개의 WKA를 설정하는 방법은 다음 문서를 참고 하세요.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/middleware/12213/coherence/COHDG/setting-cluster.htm#COHDG5454&quot;&gt;Using Well Known Addresses&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -server -Xms512m -Xmx512m -cp /home/opc/fmw/coherence/lib/coherence.jar:/home/opc/fmw/coherence/lib/coherence-web.jar -Dcoherence.mode=prod -Dcoherence.management.remote=true -Dcoherence.session.localstorage=true -Dcoherence.enable.sessioncontext=true -Dcoherence.cacheconfig=default-session-cache-config.xml -Dcoherence.cluster=mycoh -Dcoherence.wka=10.0.3.3 com.tangosol.net.DefaultCacheServer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스크립트를 실행 시켜 Coherence를 기동 시킵니다. 아래와 유사한 로그가 보여질 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image54.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;coherence1 구성이 완료 되었으면 Custom Image를 생성해서 두번째 Instance를 생성합니다.&lt;/p&gt;

&lt;p&gt;생성하는 과정은 생략하도록 하겠습니다. 생성된 후의 모습은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image55.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Coherence 구성은 완료된 상황이기 때문에 Coherence 설치 디렉토리로 이동하여 Coherence 구동 스크립트를 실행 시켜 줍니다.&lt;/p&gt;

&lt;h1 id=&quot;jcs에서-coherence-설정&quot;&gt;JCS에서 Coherence 설정&lt;/h1&gt;

&lt;p&gt;이 단계에서는 JCS의 세션을 Coherence에 저장하도록 설정하는 과정을 수행합니다. 
그렇게 하기 위해서는 WebLogic의 Managed Server들을 앞 단계에서 설정한 Coherence Cluster에 &lt;strong&gt;Join&lt;/strong&gt; 되게 해 주어야 합니다.&lt;/p&gt;

&lt;p&gt;이 설정은 WebLogic Console을 통해 수행해야 하는데 JCS가 Private Subnet에 생성 되었기 때문에 JCS 메뉴에 있는 “WebLogic Console” 열기를 통해서는 콘솔에 접속할 수 없습니다.&lt;/p&gt;

&lt;p&gt;따라서 앞서 Web 설정에서 /console Location을 추가 해 두었기 때문에 웹서버(Apache)의 Public IP를 통해 웹로직 콘솔에 접속합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http://[웹서버-Public-IP]/console&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JCS의 WebLogic Cluster들은 Cohernece Cluster의 기본 구성을 사용하도록 설정되어 있습니다. 여기에서는 Default로 구성되는 Coherence를 사용하지 않고 Stand Alone으로 구성된 Coherence에 Join할 것이 때문에 아래 화면에서 설명하는 방법을 따라 Coherence Cluster에서 WebLogic Cluster를 멤버에서 제거해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image57.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image58.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멤버에서 잘 제외 되었는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image59.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버 메뉴로 이동하여서 각 WebLogic Managed Server가 구동할 때 Coherence Cluster의 멤버로 Join할 수 있도록 WebLogic Managed Server의 Start Script 부분을 수정해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image60.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image61.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 설정되어 있는 Start Script의 Arguments를 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image62.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 Argument를 다음과 같이 수정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image63.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Argument 전체 부분을 변경하면 안되고, 아래 빨간색으로 표시된 부분만 변경 될 수 있도록 합니다. &lt;strong&gt;기존 Argument에서 -Dtangosol.coherence.transport.reliable=tmb -Dtangosol.coherence.socketprovider=tcp 이 두 옵션은 제외해야 하니 주의 하세요.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Xms256m -Xmx8192m -XX:MaxMetaspaceSize=2048m -Djdk.tls.rejectClientInitiatedRenegotiation=true -Xloggc:/u01/data/domains/privJCS2_domainGC_privJCS2_server_1.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=4 -XX:GCLogFileSize=5m -Dweblogic.rjvm.enableprotocolswitch=true -Djava.net.preferIPv4Stack=true -Doracle.security.jps.db.connect.max.retry=720 -Doracle.security.jps.db.connect.retry.interval=10000 -Djps.auth.debug=false -DUSE_JAAS=false -Djps.combiner.optimize.lazyeval=true -Djps.combiner.optimize=true -Djps.authz=ACC -Djps.subject.cache.key=5 -Djps.subject.cache.ttl=600000 -Dweblogic.security.SSL.minimumProtocolVersion=TLSv1.2 -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Dweblogic.data.canTransferAnyFile=true -Djava.security.egd=file:/dev/./urandom -XX:CompileThreshold=8000 -XX:ReservedCodeCacheSize=1024m -Doracle.jdbc.fanEnabled=false -Dcoherence.session.localstorage=false -Dcoherence.enable.sessioncontext=true -Dcoherence.cluster=mycoh -Dtangosol.coherence.cluster=mycoh -Dcoherence.wka=10.0.3.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스크립트 변경이 완료되었으면 웹로직 서버를 재기동해야 합니다. 아래와 같이 &lt;strong&gt;Control&lt;/strong&gt; 탭으로 이동하여 해당 서버만 재기동 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image64.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image65.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버가 정상적으로 기동되고 나면 세션 테스트을 위핸 샘플 애플리케이션을 배포해야 합니다.&lt;/p&gt;

&lt;h1 id=&quot;애플리케이션-배포&quot;&gt;애플리케이션 배포&lt;/h1&gt;

&lt;p&gt;세션 테스트를 위햔 애플리케이션은 세션을 사용하는 어떤 애플리케이션을 이용하여도 무방합니다. 애플리케이션에서 Coherence*Web을 사용하게 하기 위해서는 &lt;strong&gt;weblogic.xml&lt;/strong&gt; 에 다음과 같은 설정만 추가해 주면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;wls:session-descriptor&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;wls:persistent-store-type&amp;gt;&lt;/span&gt;coherence-web&lt;span class=&quot;nt&quot;&gt;&amp;lt;/wls:persistent-store-type&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/wls:session-descriptor&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기에서는 간단한 샘플 애플리케이션(cohweb)을 이용할 것입니다.&lt;/p&gt;

&lt;p&gt;웹로직 콘솔의 &lt;strong&gt;Deployments&lt;/strong&gt; 메뉴에서 애플리케이션을 배포합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image66.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로컬 환경에서 JCS Cloud 환경으로 애플리케이션을 &lt;strong&gt;Upload&lt;/strong&gt;해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image67.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image68.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image69.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image70.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션을 Cluster에 배포합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image71.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image72.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image73.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image74.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션이 배포되고 나서는 애플리케이션을 시작 시켜야 서비스를 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image75.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션이 서비스 가능 상태가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image76.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AD2의 JCS도 위와 마찬가지로 설정해 줍니다. 동일하게 애플리케이션도 배포해 줍니다.&lt;/p&gt;

&lt;h1 id=&quot;load-balancer-생성&quot;&gt;Load Balancer 생성&lt;/h1&gt;

&lt;p&gt;마지막으로 Load Balancer를 생성해 줍니다. 이 Load Balancer는 web1, web2를 Round Robin으로 발란싱하게 구성합니다.
Load Balancer는 &lt;strong&gt;Sticky Session&lt;/strong&gt;을 지원하도록 설정할 수도 있지만, HA 태스트를 위해서 web1, web2로 Round Robin으로 돌리며 테스트를 진행할 예정이기 때문에 Sticky Session으로 설정하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image77.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image78.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성이 되고 나면 다음과 같이 보여집니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image79.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;test&quot;&gt;Test&lt;/h1&gt;

&lt;p&gt;이제 구성된 Load Balancer를 통해서 Application을 테스트 해 보겠습니다. Load Balancer의 Public IP로 접속합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http://[Load-Balancer-Public-IP]/cohweb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 화면이 보일 것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image80.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세션을 몇개 추가해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image81.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;브라우저의 Refresh 버튼을 클릭하여 request를 계속 보내 봅니다. 다른 JCS Server 접속된 것을 확인할 수 있고, 세션이 유지되는 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/3tier/image82.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래는 3 Tier의 각 컴포넌트를을 차례로 Down 시키면서 세션이 유지되는지 테스트하는 과정입니다.
각 Layer의 컴포넌트를 하나씩 내려 보면서 세션이 계속 유지되는지 테스트 해보시면 HA 아키텍처를 이해하는데 더욱 도움이 될 것입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;먼저 정상 상황에서 서로 다른 두 WebLogic Server간의 세션 공유가 됨을 확인 합니다.&lt;/li&gt;
  &lt;li&gt;Coherence (Http Serssion 서버) 노드를 하나 다운 시키고 나서 세션이 공유 됨을 확인합니다.&lt;/li&gt;
  &lt;li&gt;제일 앞단의 로드 발란서에서 웹서버 사이의 로그 발란싱 정책은 Round Robin 입니다. 세션에 상관없이 이 구간에서는 Round Robin으로 동작하지만 웹서버 WebLogic Server 구간은 Sticky Session이 적용됩니다. 따라서 현재 접속되어 있는 WebLogic Server 정보를 확인하고 해당 서버를 Down 시킴으로써, 요청이 다른 서버로 이동되게 합니다. 이 경우에도 정상적으로 세션이 유지됨을 확인 합니다.&lt;/li&gt;
  &lt;li&gt;마지막으로 웹서버를 다운 시켜서 로드 발란서에서 살아있는 웹서버로만 요청이 이루어짐을 확인 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;iframe width=&quot;710&quot; height=&quot;410&quot; src=&quot;https://www.youtube.com/embed/EiXjE82FuCI&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;이상으로 모든 구성이 완료되었습니다.&lt;/p&gt;</content><author><name></name></author><category term="Oracle Cloud" /><category term="Virtual Cloud Network" /><category term="IaaS" /><category term="3 Tier Architecture" /><category term="HA" /><category term="Java Cloud Service" /><summary type="html">이 문서에서는 다음과 같은 가장 일반적인 3-Tier 아키텍처 기반의 웹 시스템을 Oracle Cloud Infrastructure(IaaS)와 Java Cloud Service(PaaS)를 이용하여 구축하는 방법에 대해서 기술합니다.</summary></entry><entry><title type="html">Digital Assistant(챗봇)와 Content and Experience(CECS) 연동하기</title><link href="http://localhost:4000/chatbot/2019/chatbot_cecs/" rel="alternate" type="text/html" title="Digital Assistant(챗봇)와 Content and Experience(CECS) 연동하기" /><published>2019-02-19T00:00:00+09:00</published><updated>2019-02-19T00:00:00+09:00</updated><id>http://localhost:4000/chatbot/2019/chatbot_cecs</id><content type="html" xml:base="http://localhost:4000/chatbot/2019/chatbot_cecs/">&lt;p&gt;이 포스트에서는 오라클 챗봇인 &lt;strong&gt;Digital Assistant&lt;/strong&gt;와 &lt;strong&gt;Content and Experience Cloud (이후 CECS)&lt;/strong&gt;라는 Content 관리 솔루션과 연계하는 방법에 대해서 다룰 것입니다.&lt;/p&gt;

&lt;p&gt;챗봇을 통해서 CECS에 저장되어 있는 컨텐츠를 검색하고 검색된 결과 문서나 폴더의 &lt;strong&gt;Public Link&lt;/strong&gt;를 통해서 바로 해당 컨텐츠를 확인할 수 있는 예제를 설명할 것입니다.&lt;/p&gt;

&lt;p&gt;이를 위해서는 Chatbot의 커스텀 컴포넌트 작성이 필요한데, 커스텀 컴포넌트 작성과 관련하여서는 이전 기고에서 몇 차례 다루었기 때문에 여기에서는 CECS 연계 코드 부분만 설명하도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/chatbot_adw/&quot;&gt;챗봇 커스텀 컨포넌트 작성 및 Compute CS에서 커스텀 컴포넌트 구동하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/chatbot/2019/챗봇-Embedded-Container/&quot;&gt;Embedded Container에 커스텀 컴포넌트 올리기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사전-준비-사항&quot;&gt;사전 준비 사항&lt;/h2&gt;
&lt;p&gt;아래 서비스가 미리 생성되어 있어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Oracle Digital Assistant (ODA)&lt;/li&gt;
  &lt;li&gt;Oracle Content and Experience Cloud (CECS)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;custom-component&quot;&gt;Custom Component&lt;/h2&gt;
&lt;p&gt;CECS 연동을 위해서는 CECS에서 제공하는 REST API를 사용할 것 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/en/cloud/paas/content-cloud/rest-api-documents/rest-endpoints.html&quot;&gt;CECS REST API 참고하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 포스트에서는 컨텐츠 검색과 컨텐츠 접근을 위해서 Public Link를 얻어오는 기능을 사용하기 때문에 다음 두개의 REST API를 사용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/en/cloud/paas/content-cloud/rest-api-documents/op-documents-api-1.2-folders-search-items-get.html&quot;&gt;Search Folders or Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/en/cloud/paas/content-cloud/rest-api-documents/api-publiclinks.html&quot;&gt;Publiclinks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제는 챗봇으로 부터 컨텐츠 검색을 위한 &lt;strong&gt;keyword&lt;/strong&gt;를 입력받고 keyword에 해당하는 컨텐츠를 검색한 후, 해당 컨텐츠의 publiclink 정보를 가저와서 챗봇에 보내준 후 챗봇의 url 버튼 기능을 이용하여 해당 컨텐츠로 이동하는 예제 입니다.&lt;/p&gt;

&lt;p&gt;작성된 커스텀 컴포넌트 Code Snippet은 다음과 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;searchcecsjs&quot;&gt;searchcecs.js&lt;/h3&gt;
&lt;p&gt;cecs의 REST API를 호출하고 챗봇에 보여줄 메시지를 생성하는 Custom Component 로직입니다.
이 코드에서 &lt;strong&gt;publiclink&lt;/strong&gt;에 해당하는 부분을 각자 환경에 맞게 수정합니다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 생략&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://[CECS DOMAIN]/documents/link/&quot;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;searchapi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/folders/search/items&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicfilelinkapi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/publiclinks/file/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicfolderlinkapi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/publiclinks/folder/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 생략&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mee-nam-lee/chatbot/blob/master/bot-start/components/searchcecs.js&quot;&gt;전체 searchcecs.js 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;utiljs&quot;&gt;util.js&lt;/h3&gt;
&lt;p&gt;REST API를 실제로 호출하는 코드 입니다. &lt;strong&gt;baseForAPI&lt;/strong&gt;와 &lt;strong&gt;auth&lt;/strong&gt; 부분의 각자 환경에 맞게 수정합니다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 생략&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baseForAPI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://[CECS CLOUD DOMAIN]/documents/api/1.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;auth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Basic '&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'[USERID]:[PASSWORD]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'base64'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 생략&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mee-nam-lee/chatbot/blob/master/bot-start/components/utils/util.js&quot;&gt;전체 util.js 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bot에서-custom-컴포넌트-연결&quot;&gt;Bot에서 Custom 컴포넌트 연결&lt;/h2&gt;
&lt;p&gt;Custom 컴포넌트 연계 방법은 이전 포스트를 참고하시기 바랍니다. 컴포넌트가 연결되고 나면 아래와 같이 서비스가 보이게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_cecs/cecs_service.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bot-dialogue-flow&quot;&gt;Bot Dialogue Flow&lt;/h2&gt;
&lt;p&gt;Flow는 다음과 같이 구성합니다. &lt;strong&gt;keyword&lt;/strong&gt;를 입력 받아서 custom component의 &lt;strong&gt;properties&lt;/strong&gt;로 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;states&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;askKeyword&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System.Text&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;검색하실&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;키워드를&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입력해&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;주세요&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;keyword&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
    
  &lt;span class=&quot;na&quot;&gt;searchCECS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;searchcecs&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;keyword&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;${keyword}&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;transitions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;done&quot;&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;test&quot;&gt;Test&lt;/h2&gt;
&lt;p&gt;Web Chat 채널을 통해 테스트 하게 되면 다음처럼 보이게 됩니다. 검색된 결과의 &lt;strong&gt;링크 열기&lt;/strong&gt;를 클릭하면 해당 문서 보기로 이동하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/chatbot_cecs/chatbot_cecs_result.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;챗봇의 내장 Test UI에서는 다음처럼 보여집니다. 
&lt;img src=&quot;/assets/images/chatbot_cecs/testui_result.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모두 완료되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/en/cloud/paas/content-cloud/rest-api-documents/rest-endpoints.html&quot;&gt;CECS REST API 참고하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Oracle 챗봇 컴포넌트 작성을 위한 자세한 SDK 가이드는 다음을 참고하세요&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/oracle/bots-node-sdk/&quot;&gt;Oracle Bots Node.js SDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="chatbot" /><category term="오라클 챗봇" /><category term="CECS" /><summary type="html">이 포스트에서는 오라클 챗봇인 Digital Assistant와 Content and Experience Cloud (이후 CECS)라는 Content 관리 솔루션과 연계하는 방법에 대해서 다룰 것입니다.</summary></entry></feed>